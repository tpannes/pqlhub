/* v4.96
 *
 *    .d8888b.                888          8888888888                                    888
 *   d88P  Y88b               888          888                                           888
 *   888    888               888          888                                           888
 *   888         .d88b.   .d88888  .d88b.  8888$888    888  888 88888b.   .d88b.  888d888 888888
 *   888        d88""88b d88" 888 d8P  Y8b 888        `Y8bd8P  888 "88b d88""88b 888P"   888
 *   888    888 888  888 888  888 88888888 888          X88K   888  888 888  888 888     888
 *   Y88b  d88P Y88..88P Y88b 888 Y8b.     888        .d8""8b. 888 d88P Y88..88P 888     Y88b.
 *    "Y8888P"   "Y88P"   "Y88888  "Y8888  8888888888 888  888 88888P"   "Y88P"  888      "Y888
 *                                                             888
 *                                                             888
 *                                                             888
 *                                                             
 * created by TimoP, initial version released 03/2010, 
 * credits to RalfH / ManfredG / MarcoP for some nice ideas and testing
 *
 * 
 * Desciption:
 * This script exports PQL code from a defined set of objects and DOCDEF code from a defined set of resources to the
 * local filesystem. PQL code can be extracted from classes, templates or instances which are specfied by an array of
 * export definitions like "T:<PQL>CF3*" which would export all PQL code from templates of type PQL whose name starts 
 * with "CF3". DOCDEF code is extracted from either DFA or INC resources that can be specified by wildcard definitions 
 * like "CF3*" or by fix names.
 * In addition a code check can be performed to e.g. find print statements or hardcoded object IDs.
 * The code checking is done via a list of pre-defined regular expressions and can be easily extended.
 * The script can be adjusted via a couple of variables in section "Configuration" below. 
 * It returns the number of exported objects.
 * 
 * Notes: 
 * - script has to run on a local node running under windows 
 * - for better readability, your kernel window size should have a width of at least 180 characters.
 * 
 * History:
 *   v1.0: initial version
 *   v1.1: some minor fixes
 *   v1.2: 
 *       - minor fixes
 *       - DataGenericBinary is searched directly underneath node object
 *       - data object is removed if it was created by script
 *   v1.3:
 *       - new feature: warnings for hardcoded OIDs in PQL code
 *       - ignore "empty" PQLExecute methods (e.g. material methods)
 *       - use "like" instead of "upper()" to compare method name with "PQLEXECUTE"
 *       - verbose mode switch 
 *   v1.4:
 *       - filenames are suffixed by method ID in hex in case several methods have the same internal name
 *       - if paramcount > 1 then PQLCode is taken from last param containing a PQL statement
 *       - exportPath is extended by a backslash if missing
 *       - display line number in warnings
 *   v1.5:
 *       - header information for PQL-methods is written into output file (description, pre-constraints, visible name, params, ...)
 *       - small corrections
 *   v1.6: 
 *       - improved message system (support for additional types of warnings)
 *       - data object is always created (and removed)
 *       - simulation mode (only kernel output, no filesystem export)
 *       - possibility to define a fixed set of classes/objects to export (e.g. if there is no common prefix)
 *   v1.7:
 *       - support for PQL code defined in attr/method properties like "pre conditions" etc.
 *       - code refactoring
 *   v1.8:
 *       - export to subdirectory with current datestamp
 *       - optimized code checking
 *   v1.9:
 *       - separate subdirectories for DFA, PQL and (in the future) XML files for class definitions
 *       - user defined classes can be added to classes specified via prefix
 *       - fixed bug where batch file (= output folders) is only created when PQL export is activated
 *       - improved messages
 *       - check if resources have binary content
 *       - instantiate helper objects transient (in memory)
 *   v2.0:
 *       - export code-check messages to CSV file
 *       - code refactoring
 *       - code checking for DFA
 *       - possibility to define classes to exclude from export 
 *       - updated regex defintions for code checker
 *       - message command used instead of print
 *       - do not create output folders if there are no files
 *   v2.1 
 *       - fixed bug where CSV file is not written
 *       - updated regex table
 *       - added toggle for header sections in PQL methods 
 *       - added support for PQL code in $Substitution properties
 *   v2.2
 *       - new setting to export all versions of a class:  @includeVersionChain
 *       - support for class duplicates after TRF import with option "allow import of different class with same internal name" 
 *   v2.3
 *       - added parameter interface that allows to call this script from external, e.g. to use it in custom tool class    
 *   v3.0:
 *       - export of class definitions in XML format
 *   v3.0.2:
 *       - improved check for valid resources by looking for string "$$Binary$$" in attribute 
 *       - improved search for PqlExecute methods by using filter "PqlExecute*" (to take also "PqlExecuteWithoutEvent" methods into account)
 *   v3.1:
 *       - fixed bug where $substitution property was not exported correctly
 *       - added index to filenanmes for multivalue attribute properties 
 *   v3.2:
 *       - API extension: search expression for code checker can be defined externally (one at a time) which will override built-in regex definitions
 *   v3.3:
 *       - separators for output filenames are now configurable
 *   v3.5:
 *       - support for PQL code export from templates and instances
 *       - redesigned interface (API) for external calls to support more parameters 
 *   v3.6:
 *       - fixed support for complete version chain export (renamed parameter to "Include Version Chain")
 *       - attribute, method and parent/child IDs are output in hex format (only stateID remains decimal) 
 *       - added class/template internal name to filenames for instances and templates
 *       - extended interface with two new settings "CodeExportMethodIdSeparator" and "CodeExportClassObjNameSeparator"
 *   v3.6.1:
 *       - bugfix: corrected handling for percent signs in PQL code during export 
 *       - bugfix: corrected DFA file names
 *   v3.7:
 *       - PQL statements from material methods are now exported  
 *       - SortIndex property is written in hex format
 *       - fixed bug where methodIDs were appended to filename unnecessarily
 *       - timestamp added to filenames if option "IncludeVersionChain" is on
 *   v3.8:
 *       - introduced template / instance file naming scheme so users can define filenames in a more flexible way
 *   v3.9:
 *       - use internal function "BinaryExportExtended" for file export if supported
 *       - minor code / performance improvement in method export loop
 *       - bugfix: duplicate method names are now handled correctly (filenames will be suffixed by methodID)
 *       - bugfix: combined XML file was not created properly before
 *       - bugfix: file counters are only increased when export was successful (in case or simulation is OFF)
 *   v4.0:
 *       - added support for new system attributes / properties: $Abstract, $Final, $Delegate, $Accessibility  
 *       - added mapping between system attributes and binary versions for backward compatibilty
 *   v4.1:
 *       - extended XML comments to support visible names for OID properties (e.g. $Author), $TransTargetState and $TransEventTypes
 *       - write user-defined search string for code checks to header line of CSV file (if available)
 *       - empty properties are now always exported into XMLs and properly formatted 
 *   v4.5:
 *       - added method parameter definitions ($ParamDef) to XML output
 *       - changed message codes (I/W/E) to be independent of EYE FW
 *   v4.51:
 *       - fixed bug related to file name generation for PQL code attributes of instances / templates
 *   v4.6:
 *       - added support for new attribute type "ProcAddr" and made code more robust to future extensions
 *       - added support for new method properties $ExecuteWithOmsAccount and $ExecuteWithOmsAccountScript
 *   v4.61:
 *       - restored backward compatibility for v7.02
 *   v4.8:
 *      - added support for framework filters to enable export of objects based on the frameworks they belong
 *      - improved code quality by using regular expressions to parse export definitions
 *   v4.9:
 *      - fixed bug where $Range property was not exported correctly when it contained PQL code
 *      - added support for new properties (e.g. for structs)
 *   v4.91:
 *      - bugfix: substitutions of $EditComboBox properties were not exported
 *   v4.95:
 *      - added support for additional properties (v7.19 ones + some old ones that were missing from the beginning)
 *   v4.96:
 *      - added support for Project(-management) scope filter, e.g. to export PQLs of objects from certain projects only
 *
 *  
 *   Known issues (will not affect functionality)
 *   - on systems, where "BinaryExportExtended" is not supported, the output directories are created by a batch script 
 *     which has following drawbacks:
 *     - ExternalApplication tool is instantiated in same transaction which leads to warning messages "POTR0035W Object ... not found" (Can be avoided using $transaction() in v7.1)
 *     - Batch file doesn't set errorcode of 0 which leads to error message like "POTR0056E External process 'D:\CodeExport\codeexport.bat' ended with RC=1(1)"
 *   - invalid characters in XML comments are not handled, e.g. german umlauts in attribute descriptions 
 */


//====BEGIN_CONFIGURATION=========================================================================================================================
Option ExecutionFlags = $io, $im;

// Basic settings
// (number in square brackets shows to which parameter the variable corresponds when script is called from external)
@exportDefinitionsPql       = Array();   // [1] set of classes and/or templates and/or instances for PQL export
@exportDefinitionsResources = Array();   // [2] set of DFAs/INCs that will be exported
@scopeDefinitions = $Invalid;            // [3] defines a set of frameworks / framework folders as a search result filter  
@exportPathBase = "C:\CodeExport\";      // [4] output folder path (a new subfolder will be created within this folder each time the script runs)
@export_PQL = true;                      // [5.1] switch to toggle export of PQL code
@export_DFA = true;                      // [5.2] switch to toggle export of DFAs / INCs
@export_XML = true;                      // [5.3] switch to toggle export of class definitions in XML format
@simulateExport   = true;                // [6.1] if set to 1, no files are generated, e.g. if if you only want to perform code check
@performCodeCheck = true;                // [6.2] defines whether a code check should be done (based on regular expressions)
@verboseLevel = 2;                       // [9] verbose level, set to 0 for quiet operation
     
// Advanced settings
@generatePqlHeader   = true;             // [6.3] defines whether a header section is added to each file that contains code of a PQL method 
@includeVersionChain = false;            // [6.4] defines if all versions of a class should be exported (1) or just the latest one (0)
@xmlComments         = true;             // [6.5] set to 1 for human readable output of B64 encoded content and attribute types 
@xmlCreateCombinedOutputFile = true;     // [6.6] set to 1 to create a combined XML file for all classes in addition to single output files
@userDefinedSearchExpression = $Invalid; // [7] used defind regex expression for code checker
@classPrefix             = '';           // [8.1] prefix for all output files that contain PQL code from classes
@classAttributeSeparator = '_';          // [8.2] separator between class and attribute name in output filename
@classMethodSeparator    = '_-_';        // [8.3] separator between class and method name in output filename
@propertySeparator       = '_$';         // [8.4] separator between attribute/method name and property name in output filename
@propertyIndexSeparator  = '.';          // [8.5] separator between property name and index in output filename (only applied if propery is an array, e.g. $substitution)
@methodIdSeparator       = '_';          // [8.6] separator between method name and method ID (only applied if there are multiple methods with the same name)
@templateNamingScheme    = '(T)<CLASS_NAME>_-_<OBJ_NAME>_<ATTR_NAME>_<OID>'; // [8.7] naming scheme for templates
@instanceNamingScheme    = '(I)<CLASS_NAME>_-_<OBJ_NAME>_<ATTR_NAME>_<OID>'; // [8.8] naming scheme for instances
@invalidCharReplacement  = '_';          // [8.9] replacement character(s) for invalid characters in instance/template names



// Regular expression table used during code checking
// [regex] | [message] | [num chars to print before match] | [num chars to print after match] 
@searchExpressions = Array(
  {'[\\="' + "'{,][\s]*[0-9A-Fa-f]{1,3}\.[0-9A-Fa-f]{1,3}\.[0-9A-Fa-f]{1,8}\.[0-9A-Fa-f]{1,8}[\s]*[\\'" + '"};,] ', "hardcoded object ID", 32, 32},
  {"\$[1-9A-Fa-f]+[:(]"               ,   "hardcoded node ID", 16, 16},
  {"(PRINT|Print|print)\(['"+'"]'     ,   "print statement", 0, 32},
  {"//[ \t]*(TODO|ToDo|todo|2do)"    ,    "open TODO", 0, 32},
  {"(IF|if)[ \t]*\(0\)"               ,   "commented PQL code fragment", 0, 32},
  {"[\s]*(IF 1==0|IF 0==1|IF 0)[\s]*" ,   "commented DFA code fragment", 0, 32},
  // feel free to extend this table for your own needs, e.g. if you want to find forgotten Hugo's :-)
  {"HUGO|Hugo|hugo"                   ,   '"Hugo"', 16, 16} 
);
  
//====END_CONFIGURATION===========================================================================================================================










// ===- Initialization and preparation -===


// constants
@VERSION     = "v4.96";
@MSG_ERROR   = 'PFGM0001E';
@MSG_WARNING = 'PFGM0002W';
@MSG_INFO    = 'PFGM0003I';
@CR = char(10);
@CRLF = char(10)+char(13);
@TAB  = char(9);
@PERCENT = char(37);
@STAR = '*';
@OBJECT_TYPE_CLASSES   = 1;
@OBJECT_TYPE_TEMPLATES = 2;
@OBJECT_TYPE_INSTANCES = 3;
@PQLPARAMPREFIX = 'PQLStatement=';
@EDITMODE_PQLSTATEMENT = 'PQL Statement';
@METHOD_PARAMS_PROPERTY_NAME = 'ParamDef';
@EXECUTION_MODE_DEFAULT       = 1;
@EXECUTION_MODE_METHOD_PARAMS = 2;
@FILE_EXTENSION_PQL = '.pql';
@FILE_EXTENSION_XML = '.xml';
@FILENAME_FORBIDDEN_CHARS = array('?','/','\','<','>',':','"','|','*',@PERCENT);
@DIR_SEPARATOR_WINDOWS = '\';
@DIR_SEPARATOR_UNIX    = '/';
@CSV_HEADER_LINE       = 'FILENAME;LINE;POSITION;MESSAGE_TYPE;CODE_CONTEXT';
@CSV_HEADER_SEARCHTEXT = 'SearchExpression: ';
@hexFormatString='@v.X@'; // for method IDs
@hexIdPrefix = "0x";
@exportFolderDFA = 'DFA';
@exportFolderPQL = 'PQL';
@exportFolderXML = 'XML';
@exportFileCodeCheck = 'code_checker.csv';
@codeCheckSeparator = ';';
@filenameOptionsSeparator = ';';
@filenameComponentSeparator = '_';
@dateTimeSeparator = '-';
@date = Substitute(ToString(date()),"/","")+"_"+Substitute(ToString(time()),":","");


// check if we are called from external - in that case override configuration variables with input parameters
// $param5 is always mandatory, so its a good candidate for checking this
@externalCall = false;
if ($param5 !=$invalid) then
  @externalCall = true;
endif 
  
if (@externalCall) then
  @exportDefinitionsPqlDefined       = ($param1 !=$invalid && Count($param1)>0 && $param1[1] != "");
  @exportDefinitionsResourcesDefined = ($param2 !=$invalid && Count($param2)>0 && $param2[1] != "");
  if ( @exportDefinitionsPqlDefined || @exportDefinitionsResourcesDefined ) then
    if (@exportDefinitionsPqlDefined)       then @exportDefinitionsPql       = $param1; endif
    if (@exportDefinitionsResourcesDefined) then @exportDefinitionsResources = $param2; endif
    @scopeDefinitions = $param3;
    @exportPathBase   = $param4;
    @exportTypes      = toInt($param5);
    @export_PQL       = (@exportTypes & 1) >0; // lowest bit defines if PQL code is exported
    @export_DFA       = (@exportTypes & 2) >0; // second lowest bit defines if DFA code is exported
    @export_XML       = (@exportTypes & 4) >0; // third lowest bit defines if class definitions are exported in XML format
    if ($param6 !=$invalid) then 
      @flags    = $param6;
      @simulateExport              = (@flags &  1) > 0;  
      @performCodeCheck            = (@flags &  2) > 0;
      @generatePqlHeader           = (@flags &  4) > 0;
      @includeVersionChain         = (@flags &  8) > 0;
      @xmlComments                 = (@flags & 16) > 0;
      @xmlCreateCombinedOutputFile = (@flags & 32) > 0;
    endif
    if ($param7!=$invalid) then
      @userDefinedSearchExpression = $param7; 
      @searchExpressions  = Array({@userDefinedSearchExpression, "match", 32, 32});
      @csvLastColumnIndex = RPos(';', @CSV_HEADER_LINE);
      @csvLastColumnName  = Right(@CSV_HEADER_LINE, Length(@CSV_HEADER_LINE)- @csvLastColumnIndex);
      @csvLastColumnNameNew = '"' + @csvLastColumnName + ' ### '+@CSV_HEADER_SEARCHTEXT + Substitute(@userDefinedSearchExpression, '"', '""') + ' ###"';
      @CSV_HEADER_LINE = Substitute(@CSV_HEADER_LINE, @csvLastColumnName, @csvLastColumnNameNew);
    endif
    if ($param8!=$invalid) then 
      @filenameOptions   = split($param8,@filenameOptionsSeparator);
      @classPrefix             = @filenameOptions[1];
      @classAttributeSeparator = @filenameOptions[2];
      @classMethodSeparator    = @filenameOptions[3];
      @propertySeparator       = @filenameOptions[4];
      @propertyIndexSeparator  = @filenameOptions[5];
      @methodIdSeparator       = @filenameOptions[6];
      @templateNamingScheme    = @filenameOptions[7];
      @instanceNamingScheme    = @filenameOptions[8];
      @invalidCharReplacement  = @filenameOptions[9];
    endif
    if ($param9!=$invalid) then @verboseLevel = $param9; endif
  else 
    message(@MSG_ERROR,'CodeExport '+@VERSION+': Not all mandatory input parameters have been provided');   
  endif
endif

// match expression table for export definitions
// [ObjType | ObjType Name | ObjType Match Expression]
@EXPORTDEF_MATCH_TABLE = {
  { @OBJECT_TYPE_CLASSES,   'classes',   '^C:()([a-zA-Z0-9_\*]*)$'},
  { @OBJECT_TYPE_TEMPLATES, 'templates', '^T:<([a-zA-Z0-9_\*]+)>([a-zA-Z0-9_\*]+)$'},
  { @OBJECT_TYPE_INSTANCES, 'instances', '^I:<([a-zA-Z0-9_\*]+)>([a-zA-Z0-9_\*]+)$'}
};

@WILDCARD_SEARCHES = {
'C:*',
'T:<*>*',
'I:<*>*'
};

// human readable description of attibute types
@attrTypeTable = Array('1','2','3','4','Integer','6','Float','String','9','Memory','Objref','12','Date/Time','14','Binary',
                       'Boolean','Binary remote','18','19','20','21','22','23','24','25','26','27','28','29','30','31','Date',
                       'Time','34','35','36','GUID','38','AttrDefKey','40','41','ProcAddr','43','Struct');

// human readable description of specific property values (attention: related values are zero based!)
@transEventTypeTable = Array('Call','Absolute time','Relative time','Change','Call tool','Call material','Program');
@classUsageTable     = Array('Class only','Struct only','Class and struct');
// 20151221: Not yet useable (first two options result in empty property, the third one relates to value 2)
//@translateNameTable  = Array('No translation','Translation via translation collection','Language specific values');

// list of system attributes to query
@sysattrList = {"$Id","$InternalName","$DisplayName","$Created","$Modified","$Author","$Inheritance","$LogicalGUID","$VersionGUID","$Enginestatus","$ObjectDescription","$Background","$Icon","$ObjType" };

// prefixes in attribute properties that indicate PQL code
@propertyPrefixPQLTable      = Array('Pqlstatement=', 'PQL:', 'Pql:');
@propertyPrefixPQLTableCount = count(@propertyPrefixPQLTable);

// List of method properties that may contain PQL code ($Param is not covered here as its treated separately)
// [Internal name               |   Visible Name                  | Required binary version ]
@methodPropertyTable = Array(
{'$PreConstraints'              ,   'PreConstraints'              , 7.00       },
{'$PostConstraints'             ,   'Expression'                  , 7.00       },
{'$ExecuteWithOmsAccountScript' ,   'ExecuteWithOmsAccountScript' , 7.17014313 },
{'$LinePar'                     ,   'LinePar'                     , 7.00       },
{'$EnvironmentVariables'        ,   'EnvironmentVariables'        , 7.16       }
);

// List of attribute properties that may contain PQL code
// [Internal name   |   Visible Name      | Is Array | Only valid for $EditMode | Required binary version]
@attributePropertyTable = Array(
{'$Constraints'     ,   'Constraints'     , 0, '*'                                         , 7.00},
{'$Range'           ,   'InputRange'      , 0, '*'                                         , 7.00},
{'$ViewConstraints' ,   'ViewConstraints' , 0, '*'                                         , 7.00},
{'$EditConstraints' ,   'EditConstraints' , 0, '*'                                         , 7.00},
{'$Substitutions'   ,   'Substitutions'   , 1, {'MultiListBox', 'ComboBox', 'EditComboBox'}, 7.00}
);

// Class feature table
// {  Name          ,   XML list tag name    ,   XML entry tag name     }  
@featureMappingTable = Array(
{'ClassDef'         ,   ''                   ,   'ClassDefinition'      },
{'AttrDef'          ,   'AttributeList'      ,   'AttributeDefinition'  },
{'MethDef'          ,   'MethodList'         ,   'MethodDefinition'     },
{'ParentDef'        ,   'ParentRefList'      ,   'ParentRefDefinition'  },
{'ChildDef'         ,   'ChildRefList'       ,   'ChildRefDefinition'   },
{'StateDef'         ,   'StateList'          ,   'StateDefinition'      },
//{'StateTransDef'    ,   'StateTransList'     ,   'StateTransDefinition' },
{'ParamDef'         ,   'ParamDef'           ,   'ParamDefEntry'        }  // has to be at the end 
);

// Property tables
// {Property Name, IsArray [0,1], OutputMode, BinVersion Required}
// OutputMode: 0=default (no special handling), 1=Base64, 2=LGUID, 3=AttrTypeName, 4=TransEventTypeName, 
//             5=TransTargetStateName, 6=VisibleNameForOid, 7=ClassUsageName]
@classMetadataTable = Array(
{'Id'                           ,0,0, 7.00}, // Object ID 
{'Name'                         ,0,1, 7.00}, // Visible Name
{'Internalname'                 ,0,0, 7.00}, // Internal name
{'Logicalguid'                  ,0,0, 7.00}, // Logical GUID
{'VersionGUID'                  ,0,0, 7.00}, // Version GUID
{'Created'                      ,0,0, 7.00}, // Creation Date
{'Modified'                     ,0,0, 7.00}, // Modify Date
{'Author'                       ,0,6, 7.00}, // Author
{'Inheritance'                  ,1,0, 7.00}, // Inheritance
{'Constraints'                  ,0,0, 7.00}, // Constraints
{'DontInheritMethods'           ,0,0, 7.00}, // Don't inherit methods from parent
//{'PolicyIds'                    ,0,0, 7.00}, // Policy IDs
{'MatchAll'                     ,0,0, 7.00}, // Match all object     
{'Enginestatus'                 ,0,0, 7.00}, // Initial state
{'EngineLastPar'                ,0,0, 7.00}, // Last event object ID
{'Icon'                         ,0,2, 7.00}, // Icon reference
{'Background'                   ,0,0, 7.00}, // Background color
{'ObjectDescription'            ,0,1, 7.00}, // Object Description
{'Docu'                         ,0,0, 7.00}, // Docu
{'InstanceVersioning'           ,0,0, 7.14}, // Instance Versioning
{'Accessibility'                ,0,0, 7.14}, // Accessibility
{'Abstract'                     ,0,0, 7.14}, // Abstract
{'Final'                        ,0,0, 7.14}, // Final
{'ClassUsage'                   ,0,7, 7.18}, // Class usage
{'TranslateName'                ,0,0, 7.18} // Translate Name
);

@attributeMetadataTable = Array(
{'AttrId'                       ,0,0, 7.00}, // ID
{'AttrNameVisible'              ,0,1, 7.00}, // Name
{'AttrNameIntern'               ,0,0, 7.00}, // Internal (constraints) name
{'Type'                         ,0,3, 7.00}, // Type
{'DefaultValue'                 ,0,1, 7.00}, // Default
{'Substitutions'                ,1,1, 7.00}, // Substitution
{'Description'                  ,0,1, 7.00}, // Description
{'EditMode'                     ,0,0, 7.00}, // Edit
{'Constraints'                  ,0,1, 7.00}, // Constraints
{'Multiple'                     ,0,0, 7.00}, // Multiple value
{'ClassToReference'             ,0,0, 7.00}, // Class reference
{'SubstitutionsCount'           ,0,0, 7.00}, // Value count 
{'SortIndex'                    ,0,0, 7.00}, // Sort ID
{'TypeProperty'                 ,0,1, 7.00}, // Type property
{'EditProperty'                 ,0,1, 7.00}, // Edit property
{'VisibleForEdit'               ,0,0, 7.00}, // Visible for edit
{'Range'                        ,0,1, 7.00}, // Input range
{'Format'                       ,0,0, 7.00}, // Output format
{'ViewPrivileges'               ,1,0, 7.00}, // View Privilege
{'ViewConstraints'              ,0,1, 7.00}, // View Constraints
{'EditPrivileges'               ,1,0, 7.00}, // Edit Privilege    
{'EditConstraints'              ,0,1, 7.00}, // Edit Constraints
{'ProgTypeProperties'           ,0,0, 7.00}, // Program Type property
{'ContainsExpression'           ,0,0, 7.00}, // Contains Expression
{'TranslateContent'             ,0,0, 7.00}, // Translate Content
{'Docu'                         ,1,0, 7.00}, // Docu
{'CalculateDefaultValue'        ,0,0, 7.16}, // Calculate default
{'Accessibility'                ,0,0, 7.16}, // Accessibility
{'Relationship'                 ,0,0, 7.19}  // Relationship
);

@methodMetadataTable = Array(
{'MethId'                       ,0,0, 7.00}, // Method ID
{'MethNameIntern'               ,0,0, 7.00}, // Method internal name
{'MethNameVisible'              ,0,1, 7.00}, // Method name
{'DontInherit'                  ,0,0, 7.00}, // Don't inherit to children
{'ValidForInstance'             ,0,0, 7.00}, // valid for Instance
{'ValidForTemplate'             ,0,0, 7.00}, // valid for Template
{'ValidForClass'                ,0,0, 7.00}, // valid for Clas   
{'ValidForState'                ,0,0, 7.00}, // Valid only for State machine
{'ValidForAgent'                ,0,0, 7.00}, // Valid for agent  
{'DefaultMethod'                ,0,0, 7.00}, // Default method
{'Type'                         ,0,0, 7.00}, // Method type
{'PreConstraints'               ,0,1, 7.00}, // Pre Constraints
{'PostConstraints'              ,0,1, 7.00}, // Expression
{'Privileges'                   ,1,0, 7.00}, // Privilege
{'VisibleInPopUp'               ,0,0, 7.00}, // Visible in PopUpMenu
{'VisibleInToolBox'             ,0,0, 7.00}, // Visible in Tool Box
{'LocalOnly'                    ,0,0, 7.00}, // Execute locally
{'ConnectToObject'              ,0,0, 7.00}, // Connect to object
{'ImplementedBy'                ,0,0, 7.00}, // Method implementation 
{'PrgName'                      ,0,0, 7.00}, // Par Exec
{'WrkDir'                       ,0,0, 7.00}, // Par Workd
{'LinePar'                      ,0,0, 7.00}, // Par Line
{'WindowMode'                   ,0,0, 7.00}, // Par Window
{'Description'                  ,0,1, 7.00}, // Description
{'ParamCount'                   ,0,0, 7.00}, // Parameter count
{'Param'                        ,1,1, 7.00}, // Parameter <x>
{'VersionContext'               ,0,0, 7.00}, // Version Context
{'ImplementationName'           ,0,0, 7.00}, // Method implementation name
{'Icon'                         ,0,0, 7.00}, // Icon
{'QuickLaunch'                  ,0,0, 7.00}, // Quick Launch  
{'Docu'                         ,1,0, 7.00}, // Docu
{'DisabledIfLockedForEdit'      ,0,0, 7.16}, // Disabled if locked for edit
{'ParamDef'                     ,0,0, 7.16}, // (memory buffer containing all parameter definitions)
{'EnvironmentVariables'         ,1,0, 7.16}, // Environment Variable [ImplementedBy=EYE|Shell]
{'ShellMode'                    ,0,0, 7.16}, // Shell Mode
{'ShellName'                    ,0,0, 7.16}, // Shell Name [ShellMode=2]
{'ParamHandling'                ,0,0, 7.16}, // Parameter Handling [ShellMode=2]
{'Accessibility'                ,0,0, 7.14}, // Accessibility
{'Abstract'                     ,0,0, 7.14}, // Abstract
{'Final'                        ,0,0, 7.14}, // Final
{'Delegate'                     ,0,0, 7.16}, // Delegate
{'ExecuteWithOmsAccount'        ,0,0, 7.17014313}, // Execute with OMS account
{'ExecuteWithOmsAccountScript'  ,0,1, 7.17014313}, // Execute with OMS account script
{'ValidForStruct'               ,0,0, 7.18}  // valid for Struct
);

@parentDefMetadataTable = Array(
{'RefId'                        ,0,0, 7.00}, // ID
{'RefNameVisible'               ,0,1, 7.00}, // Name
{'RefNameIntern'                ,0,0, 7.00}, // Internal (constraints) name
{'Description'                  ,0,0, 7.00}, // Description
{'Multiple'                     ,0,0, 7.00}, // Multiple value
{'VirtualReference'             ,0,0, 7.00}, // Virtual Reference
{'ClassToReference'             ,0,0, 7.00}, // Class reference
{'SortIndex'                    ,0,0, 7.00}, // Sort ID
{'PassVersionDate'              ,0,0, 7.00}, // Pass Version Date
{'SearchMethods'                ,0,0, 7.00}, // Search Methods
{'SearchAttributes'             ,0,0, 7.00}, // Serach Attributes
{'NewPrivileges'                ,1,0, 7.00}, // New Privilege
{'NewConstraints'               ,0,0, 7.16}, // New Constraints
{'DeletePrivileges'             ,1,0, 7.00}, // Delete Privilege
{'DeleteConstraints'            ,0,0, 7.16}, // Delete Constraints
{'MovePrivileges'               ,1,0, 7.00}, // Move Privilege
{'MoveConstraints'              ,0,0, 7.16}, // Move Constraints
{'Docu'                         ,1,0, 7.00}, // Docu
{'Relationship'                 ,0,0, 7.19}  // Relationship
);

@childDefMetadataTable = Array(
{'RefId'                        ,0,0, 7.00}, // ID
{'RefNameVisible'               ,0,1, 7.00}, // Name
{'RefNameIntern'                ,0,0, 7.00}, // Internal (constraints) name
{'Description'                  ,0,0, 7.00}, // Description
{'Multiple'                     ,0,0, 7.00}, // Multiple value
{'ClassToReference'             ,0,0, 7.00}, // Class reference
{'SortIndex'                    ,0,0, 7.00}, // Sort ID
{'VersionContext'               ,0,0, 7.00}, // Version Context
{'PassVersionDate'              ,0,0, 7.00}, // Pass Version Date
{'SearchMethods'                ,0,0, 7.00}, // Search Methods
{'SearchAttributes'             ,0,0, 7.00}, // Serach Attributes
{'PassMoveObject'               ,0,0, 7.00}, // Pass Move Object
{'NewPrivileges'                ,1,0, 7.00}, // New Privilege
{'NewConstraints'               ,0,0, 7.16}, // New Constraints
{'DeletePrivileges'             ,1,0, 7.00}, // Delete Privilege
{'DeleteConstraints'            ,0,0, 7.16}, // Delete Constraints
{'MovePrivileges'               ,1,0, 7.00}, // Move Privilege
{'MoveConstraints'              ,0,0, 7.16}, // Move Constraints
{'SearchQuickLaunch'            ,0,0, 7.00}, // Search Quick Launch
{'Docu'                         ,1,0, 7.00}, // Docu
{'Relationship'                 ,0,0, 7.19}  // Relationship
);

@stateTransDefMetadataTable = Array(
{'TransTargetState'             ,1,5, 7.00}, // Target state  
{'TransEventType'               ,1,4, 7.00}, // Event type
{'TransActivity'                ,1,1, 7.00}, // Action
{'TransConstraints'             ,1,1, 7.00}, // Guard
{'TransCallTriggerVisible'      ,1,1, 7.00}, // Call trigger
{'TransCallTriggerIntern'       ,1,1, 7.00}, // Internal call name
{'TransSendEvent'               ,1,0, 7.00}, // Send Event
{'TransTimeAbsolut'             ,1,0, 7.00}, // Time absolute
{'TransTimeRelativ'             ,1,0, 7.00}, // Time relative
{'TransChangeTrigger'           ,1,1, 7.00}, // Change trigger [TransEventType=Change]
{'TransStayConnected'           ,1,0, 7.00}, // Desktop stay connected
{'TransDocu'                    ,1,0, 7.00}, // Docu
{'TransDisabledIfLockedForEdit' ,0,0, 7.16}  // Disabled if locked for edit
);

@stateDefMetadataTable = Array(
{'StateId'                      ,0,0, 7.00}, // State ID
{'StateNameVisible'             ,0,1, 7.00}, // State name
{'Icon'                         ,0,0, 7.00}, // Icon
{'Background'                   ,0,0, 7.00}, // Background color
{'EntryActivities'              ,1,0, 7.00}, // Entry action
{'ExitActivities'               ,1,0, 7.00}, // Exit action
{'DoActivities'                 ,1,0, 7.00}, // Do activity
{'Attributes'                   ,1,0, 7.00}, // Valid attributes
{'ReceiveConstraints'           ,0,1, 7.00}, // Handle events if
{'SendConstraints'              ,0,1, 7.00}, // Send modification events if
{'EntryEvent'                   ,0,0, 7.00}, // Entry event
{'ExitEvent'                    ,0,0, 7.00}, // Exit event
{'DoEvent'                      ,0,0, 7.00}, // Do event
{'Docu'                         ,1,0, 7.00}  // Docu
);
ForEach @elem in (@stateTransDefMetadataTable)
  @stateDefMetadataTable = InsertValue(@stateDefMetadataTable, @elem); // AppendArray not available in v702
Next

@paramDefMetadataTable = Array(
{'InternalName'                 ,0,1, 7.16}, // Name
{'Type'                         ,0,0, 7.16}, // Type
{'Multiple'                     ,0,0, 7.16}, // Multiple value
{'Default'                      ,1,1, 7.16}, // Default [Optional=true]
{'Optional'                     ,0,0, 7.16}, // Optional
{'Description'                  ,0,1, 7.16}, // Description
{'DelegationAnchor'             ,0,0, 7.16}  // Delegation Anchor
);


// variable declarations
@self = $self.$id,$node;
@node = @self.$node;
@objCountDFA = 0;
@objCountPQL = 0;
@objCountXML = 0;
@fileHeader= '';
@codeExportTable      = Array();
@codeExportTableEntry = Array(); // [filename] [file content | 'DFACODE'] [file header | <RESOURCE_OID>]
@nonUniqueCLasses     = Array();
@codeCheckMessageTable = @CSV_HEADER_LINE+@CR;
@codeCheckMessageCount = 0;
@xml_author                = $CurrentUserId.$name;
@xml_date                  = DateTime(); 
@xml_commentPrefix         = '<!-- ';
@xml_commentSuffix         = ' -->';
@xml_minusminusReplacement = "++"; // XML-comments must not contain "--"
@xml_base64charsPerLine    = 64;
@xmlCombinedOutputFilename = "_ClassExport_" + @date + ".xml";
@xmlDataCombined           = '';

// determine directory separator of current OS platform
@nodeInformation = @node\(NodeInformation:).$id,*;
@env = fromMem(@nodeInformation.Environment);
@osPath = @env\$subset(*:.Name=='ISIS_OBJECT_SPACE').Value;
if (left(@osPath, 1)==@DIR_SEPARATOR_UNIX) then
  @dirSeparator = @DIR_SEPARATOR_UNIX;
else
  @dirSeparator = @DIR_SEPARATOR_WINDOWS;
endif  

if (right(@exportPathBase,1) != @dirSeparator) then
  @exportPathBase+=@dirSeparator;
endif
@exportPath = @exportPathBase + @date+@dirSeparator; 


// end script in case there is nothing to do
if (!@export_DFA && !@export_PQL && !@export_XML) then
  if (@verboseLevel > 0) then
    message(@MSG_INFO,'CodeExport '+@VERSION+': Nothing to do. Please activate one or more export options for DFA, PQL and XML.');
  endif
  return 0;
endif;


// determine whether function "BinaryExportExtended" is supported (if not, output folders are created via temporary batch file)
@classData        = {8a84cf10-0b7a-389b-836f-4ba000365dcd};
@classRcResource  = {86e9223c-57ac-304a-b75a-09f39618a40e};
@exportMethodData       = @classData      \$MethDef(.$ImplementationName like "BinaryExportExtended").$MethNameIntern;
@exportMethodRcResource = @classRcResource\$MethDef(.$ImplementationName like "BinaryExportExtended").$MethNameIntern;
@buildNumber = $CurrentNodeId.BuildNumber;
@binVersion = ToDouble(Substitute(@buildNumber,'.','',Pos('.', @buildNumber)+1));

// use build-in method BinaryExportExtended if supported by both frameworks and binaries
if (IsInvalid(@exportMethodData) OR IsInvalid(@exportMethodRcResource) OR @binVersion < 7.12) then
  @isBinExpExtSupported = false;
else
  @isBinExpExtSupported = true;
endif


// create helper objects needed for file export
if (@simulateExport==false) then
    
  // create temporary data object to export code to filesystem
  @dataGenericBinaryClass  = \{e1d3371a-1068-11d8-ab33-7bec1e1d933d}.$Id,$LogicalGUID;
  @exportTool = @node.call("InstantiateTransient",@DataGenericBinaryClass.$LogicalGUID);
  @exportTool = @exportTool.Return1;
  @exportToolBinAttrName = 'TargetName';

  if (!@isBinExpExtSupported) then
    // prepare batch file to create folder structure in @exportPathBase
    @cmdFileName    = 'codeexport.bat';
    @cmd_folderDFA = "";
    @cmd_folderPQL = "";
    @cmd_folderXML = "";
    if (@export_DFA) then @cmd_folderDFA = 'mkdir %1\'+@exportFolderDFA+@CRLF; endif;
    if (@export_PQL) then @cmd_folderPQL = 'mkdir %1\'+@exportFolderPQL+@CRLF; endif;
    if (@export_XML) then @cmd_folderXML = 'mkdir %1\'+@exportFolderXML+@CRLF; endif;
    @cmdFileContent = '@echo off'+@CRLF+'mkdir %1'+@CRLF+ @cmd_folderDFA + @cmd_folderPQL + @cmd_folderXML + @CRLF +'del %0' + @CRLF;

    // create temporary externalApplication object to execute a shell script that creates output folders 
    $local,$0: @externalApplicationClass = $search($classes of ExternalApplication:).$id,$LogicalGUID top 1;
    @extAppTool = @node.call("InstantiateTransient",@ExternalApplicationClass.$LogicalGUID);
    @extAppTool = @extAppTool.Return1;

    @extAppTool.Command = @exportPathBase + @cmdFileName;
    @extAppTool.WorkDir = @exportPathBase;
    @extAppTool.ToolParameters = @date;

    @fileHandle = FileOpen(@exportTool.$id,@exportToolBinAttrName,'w');
    @fileHandle.$FileWrite(@cmdFileContent);
    @fileHandle.$FileClose();
    $local($ie):@rc = @exportTool.call("BinaryExport",@exportToolBinAttrName,@exportPathBase+@cmdFileName);

    if (@rc != 0) then
      message(@MSG_ERROR,' Binary export failed for file '+@exportPathBase+@cmdFileName);  
    endif

    $local($ie):@rc = @extAppTool.LaunchOnce(); // RC is 0 even though warnings like "Object xxx not found" are shown

    if (@rc != 0) then
      message(@MSG_INFO,' Script "'+ @cmdFileName +'" ended with RC='+@rc);  
    endif
  endif
endif // (@simulateExport==false)


// header message
if (@verboseLevel > 0) then
  message(@MSG_INFO, '');
  message(@MSG_INFO, '=== CodeExport '+@VERSION+' =============================================================================');
  message(@MSG_INFO, '');
endif

// output call parameters
if (@verboseLevel >= 5 && @externalCall) then
  message(@MSG_INFO, ' Script was called from external with following parameters:');
  @idx = 1;
  // first two parameters are arrays and require some special handling for nice output..  
  while (@idx <= 3) 
    @paramString = "[";
    select (@idx)
      case 1: @paramIdx = $param1; break;
      case 2: @paramIdx = $param2; break;
      case 3: @paramIdx = $param3; break;
    endselect
    if (count(@paramIdx)==0) then
      @paramString = "[]";
    else
      forEach @s in (@paramIdx)
        @paramString+='"'+@s+'",';
      next
      @paramString = subStr(@paramString, 1, length(@paramString)-1) + ']';
    endif
    message(@MSG_INFO, ' -> $param'+@idx+'  = '  + @paramString);
    @idx++;
  next
  message(@MSG_INFO, ' -> $param4  = '  + $param4);
  message(@MSG_INFO, ' -> $param5  = '  + $param5);
  message(@MSG_INFO, ' -> $param6  = '  + $param6);
  message(@MSG_INFO, ' -> $param7  = '  + $param7);
  message(@MSG_INFO, ' -> $param8  = '  + $param8);
endif
if (@verboseLevel > 3) then
  if(@isBinExpExtSupported) then
    message(@MSG_INFO, ' "BinaryExportExtended" feature is supported');
  endif
endif 


@filterByScope = (Count(@scopeDefinitions)>0);
If (@filterByScope) Then
  If (@verboseLevel > 1) Then
    Message(@MSG_INFO, 'Scope filtering is enabled');
  Endif
  @scopeSet1 = @scopeDefinitions\$Reload(Framework:)                   .$Id,$LogicalGUID,$DisplayName;
  @scopeSet2 = @scopeDefinitions\$Reload(FrameworkFolder:)\(Framework:).$Id,$LogicalGUID,$DisplayName;
  @scopeSet3 = @scopeDefinitions\$Reload(Project:)                     .$Id,$LogicalGUID,$DisplayName;
  @scopeSet4 = @scopeDefinitions\$Reload(ProjectManagement:)\(Project:).$Id,$LogicalGUID,$DisplayName;
  @scopeSet  = Union(@scopeSet1, @scopeSet2, @scopeSet3, @scopeSet4);
  If (@includeVersionChain) Then
    @scopeGuidArray = ToArray(@scopeSet.$LogicalGUID);
    $0($im): @scopeSet = $Search($Instances Of Framework:.$LogicalGUID like @scopeGuidArray).$Id,$DisplayName;
  EndIf
  If (@verboseLevel > 3) Then
    ForEach @scope in (@scopeSet)
      Message(@MSG_INFO, ' >> '+@scope.$DisplayName +' ['+@scope.$Id+']');
    Next
  Endif
EndIf


//===- Extract DFA code from resources -===

if (@export_DFA) then
  // create set of resources to export
  @resourceSetToExport = CreateSet({});
  if (@includeVersionChain) then
    $0($im): @resourceSetToExport = $search($instances of DFA,INC:(.$name like @exportDefinitionsResources)).$id,$name,$created,Content,Type;
  else
    $0($v,$im): @resourceSetToExport = $search($instances of DFA,INC:(.$name like @exportDefinitionsResources)).$id,$name,$created,Content,Type;
  endif
  if (@filterByScope) then
    $0($v,$im): @resourceSetToExportFw = @scopeSet\(DFA,INC:.$name like @exportDefinitionsResources).$id,$name,$created,Content,Type;
    @resourceSetToExport = Intersection(@resourceSetToExport, @resourceSetToExportFw);
  endif

  forEach @resource in (@resourceSetToExport)
    if (toString(@resource.Content) like '$$Binary$$*') then
      // add entry to codeExportTable
      @fileNameAppendix = '';
      if (@includeVersionChain) then
        @creationDate = ToString(@resource.$Created);
        @creationDate = Substitute(@creationDate,":","");
        @creationDate = Substitute(@creationDate,"/","");
        @creationDate = Substitute(@creationDate," ","-");
        @creationDate = Left(@creationDate, Length(@creationDate)-2);
        @fileNameAppendix = @methodIdSeparator + @creationDate + @methodIdSeparator + @resource.$id;
      endif
      @fileName = @resource.$name + @fileNameAppendix+ "." + @resource.Type;
      @codeExportTableEntry = {'DFA', @fileName,'DFACODE',@resource.$id};
      @codeExportTable = insertValue(@codeExportTable,@codeExportTableEntry);
    endif
  next
endif // (@export_DFA)



//===- Generate list of relevant objects for PQL code export -===

If (@export_PQL OR @export_XML) Then

  // create set of classes to export
  @classSetToExport    = createSet({});
  @templateSetToExport = createSet({});
  @instanceSetToExport = createSet({});
  
  // optimization to avoid unncessary wildcard searches (only if scope filter is used)
  // all objects of the specified type will be queried directly as children of the provided scope objects later.
  @skipSearch = { false, false, false };
  If (@filterByScope) Then
    @skipSearch = {
      (InArray(@exportDefinitionsPql, @WILDCARD_SEARCHES[@OBJECT_TYPE_CLASSES])),   // 1. classes
      (InArray(@exportDefinitionsPql, @WILDCARD_SEARCHES[@OBJECT_TYPE_TEMPLATES])), // 2. templates
      (InArray(@exportDefinitionsPql, @WILDCARD_SEARCHES[@OBJECT_TYPE_INSTANCES]))  // 3. instances
    };
  EndIf
 
  If (@verboseLevel > 2) Then
    @idx = 1;
    ForEach @entry In (@skipSearch)
      If (@entry) Then 
        Message(@MSG_INFO, 'Wildcard selector for '+@EXPORTDEF_MATCH_TABLE[@idx][2]+' found. Search will be skipped..');
      EndIf
      @idx++;
    Next
  EndIf

  // built lost of properties to return in class query result set
  @propertyList = Array();
  ForEach @entry in (@classMetadataTable)
    @requiredBinVersion = @entry[4];
    If (@binVersion >= @requiredBinVersion) Then
      @propertyList = InsertValue(@propertyList, '$'+@entry[1]);
    EndIf
  Next

  ForEach @exportDef In (@exportDefinitionsPql)

    If (Left(@exportDef,1)=='#' OR Trim(@exportDef)=="") Then
      Next; // ignore comments and empty lines
    EndIf
  
    @matchFound = false;
    ForEach @entry In (@EXPORTDEF_MATCH_TABLE)
      @objType         = @entry[1];
      @objTypeName     = @entry[2];
      @matchExpression = @entry[3];
      @match = RegExpMatch(@exportDef, @matchExpression);
   
      If (Count(@match)) Then
        @matchFound = true;
        @objClass = @match[2];
        @objName  = @match[3];
        If (@objClass=="" AND @objType==1) Then @objClass='*'; EndIf
        Break;
      EndIf
    Next
    
    If (!@matchFound) Then
      Message(@MSG_WARNING, ' Export definition "'+@exportDef+'" is not valid and will be ignored. Please check the syntax.');
      Next;
    EndIf  
    
    // if there is a unlimited wildcard search defined anyway, it does not make sense to search for a subset of the same object type here
    If (@skipSearch[@objType]) Then
      Next;
    EndIf
    
    If (@verboseLevel > 1) then
      Message(@MSG_INFO, ' Searching for '+@objTypeName+' of type '+@objClass+' and name "'+@objName+'"..');
    EndIf
    
    Select(@objType)
    
      Case 1: // classes
        If (@includeVersionChain) Then
          $0($im):    @set = $Search($classes of *:.$internalname like @objName).@propertyList;
        Else
          $0($v,$im): @set = $Search($classes of *:.$internalname like @objName).@propertyList;
        EndIf  
        @classSetToExport = Union(@set, @classSetToExport);
        Break;
        
      Case 2: // templates
        If (@includeVersionChain) Then
          $0($im):    @set = $Search($templates of @objClass:.$name like @objName).@sysattrList;
        Else
          $0($v,$im): @set = $Search($templates of @objClass:.$name like @objName).@sysattrList;
        EndIf
        @templateSetToExport = Union(@set, @templateSetToExport);
        Break;
          
      Case 3: // instances
        If (@includeVersionChain) Then
          $0($im):    @set = $Search($instances of @objClass:.$name like @objName).@sysattrList;
        else
          $0($v,$im): @set = $Search($instances of @objClass:.$name like @objName).@sysattrList;
        EndIf
        @instanceSetToExport = Union(@set, @instanceSetToExport);
        Break;
        
    EndSelect
    If (@verboseLevel > 3) Then
      Message(@MSG_INFO, '  -> Found '+count(@set)+' '+@objTypeName);
    EndIf  
   
  Next
  
  @objectCountTable = { Count(@classSetToExport), Count(@templateSetToExport), Count(@instanceSetToExport) };
  If (@verboseLevel > 1) Then
    @idx = 1;
    ForEach @entry In (@skipSearch)
      If (!@entry) Then
        @msgTrailer = ' for export';
        If (@filterByScope) Then @msgTrailer = ' that match export definitions'; EndIf
        Message(@MSG_INFO, 'Found '+@objectCountTable[@idx]+' '+@EXPORTDEF_MATCH_TABLE[@idx][2] + @msgTrailer);
      EndIf
      @idx++;
    Next
  EndIf

  If (@filterByScope) Then
    $0($v,$im): @classesInScope   = @scopeSet\($Classes   Of *:).@propertyList;
    $0($v,$im): @templatesInScope = @scopeSet\($Templates Of *:).@sysattrList;
    $0($v,$im): @instancesInScope = @scopeSet\($Instances Of *:).@sysattrList;
    @objectCountTableFw = { Count(@classesInScope), Count(@templatesInScope), Count(@instancesInScope) };
    If (@verboseLevel > 1) Then
      @idx = 1;
      ForEach @entry In (@objectCountTableFw)
        Message(@MSG_INFO, 'Found '+@entry+' '+@EXPORTDEF_MATCH_TABLE[@idx][2]+' matching scope filter');
        @idx++;
      Next
    EndIf

    If (@skipSearch[@OBJECT_TYPE_CLASSES]) Then
      @classSetToExport = @classesInScope;
    Else
      @classSetToExport = Intersection(@classSetToExport, @classesInScope);
    EndIf 
    If (@skipSearch[@OBJECT_TYPE_TEMPLATES]) Then
      @templateSetToExport = @templatesInScope;
    Else
      @templateSetToExport = Intersection(@templateSetToExport, @templatesInScope);
    EndIf
    If (@skipSearch[@OBJECT_TYPE_INSTANCES]) Then
      @instanceSetToExport = @instancesInScope;
    Else
      @instanceSetToExport = Intersection(@instanceSetToExport, @instancesInScope);
    EndIf 
    
    @objectCountTable = { Count(@classSetToExport), Count(@templateSetToExport), Count(@instanceSetToExport) };
    If (@verboseLevel > 1) Then
      @idx = 1;
      ForEach @entry in (@objectCountTable)
        Message(@MSG_INFO, 'Found '+@entry+' '+@EXPORTDEF_MATCH_TABLE[@idx][2]+' matching export definitions and scope filter');
        @idx++;
      Next
    EndIf    

  EndIf


EndIf // (@export_PQL OR @export_XML)



//===- Start code extraction ===-

@classIdx = 1;
@treeLevel = 1;
forEach @class in (@classSetToExport)
  
    @className = @class.$internalname;
    @classDuplicateCount = count(@classSetToExport\$Subset(*:.$InternalName==@className).$LogicalGUID groupby $LogicalGUID);
    @isDuplicateClass = (!@includeVersionChain) && (@classDuplicateCount>1);
    if (@isDuplicateClass AND !inArray(@nonUniqueCLasses, @className)) then
      @nonUniqueCLasses = InsertValue(@nonUniqueCLasses, @className);
      if (@verboseLevel>3) then
        message(@MSG_WARNING, ' -> Found '+@classDuplicateCount+' duplicates for class "'+@className+'".');
      endif
    endif
    @fileNameAppendix = '';
    if (@includeVersionChain) then
      @creationDate = ToString(@class.$Created);
      @creationDate = Substitute(@creationDate,":","");
      @creationDate = Substitute(@creationDate,"/","");
      @creationDate = Substitute(@creationDate," ","-");
      @creationDate = Left(@creationDate, Length(@creationDate)-2);
      @fileNameAppendix = @methodIdSeparator + @creationDate + @methodIdSeparator + @class.$id;
    endif


//===- Extract PQL code from attribute properties -===

  if (@export_PQL) then
    if (@verboseLevel>2) then
      message(@MSG_INFO, ' -> Extracting PQL code from class "'+@className+'" ['+@class.$id+']  ('+@classIdx+' of '+@objectCountTable[@OBJECT_TYPE_CLASSES]+')');
    endif
    @propertyList = Array('$AttrId','$AttrNameVisible','$AttrNameIntern','$EditMode');
    ForEach @entry in (@attributePropertyTable)
      @requiredBinVersion = @entry[5];
      if (@binVersion >= @requiredBinVersion) then
        @propertyList = InsertValue(@propertyList, @entry[1]);
      endif
    Next
    @attributeDefinitionSet = @class\$AttrDef.@propertyList;
    forEach @attribute in (@attributeDefinitionSet)
      @attributeName = @attribute.$AttrNameIntern;
      forEach @entry in (@attributePropertyTable)
        @attrPropertyNameIntern  = @entry[1];
        @attrPropertyNameVisible = @entry[2];
        @attrPropertyIsArray     = @entry[3];
        @attrPropertyEditMode    = @entry[4];
        @property  = @attribute.@attrPropertyNameIntern;
        @propertyCount = count(@property);  
     
        if (@attribute.$EditMode like @attrPropertyEditMode) then
          // loop through attribute property values (e.g. $substitutions can contain several values)
          @propertyIdx = 1;
          while (@propertyIdx <= @propertyCount)
          @content = @property[@propertyIdx];     
            if (left(@content,4) like 'PQL:') then
            @content = right(@content,length(@content)-4);
            @propertyIdxName = '';
            if (@attrPropertyIsArray) then
              @propertyIdxName = @propertyIndexSeparator + @propertyIdx;
            endif
            @fileName = @classPrefix + @className + @classAttributeSeparator + @attributeName + @propertySeparator + 
              @attrPropertyNameVisible + @propertyIdxName + @fileNameAppendix + @FILE_EXTENSION_PQL;
            @codeExportTableEntry = {'PQL', @fileName,@content,""}; 
            @codeExportTable = insertValue(@codeExportTable,@codeExportTableEntry);
            endif;
            @propertyIdx++;
          next     
        endif
      next
    next


//===- Extract PQL code from method definitions -===

    @propertyList = Array('$MethId','$MethNameVisible','$MethNameIntern','$ImplementationName','$Description','$Type','$Param','$Paramcount');
    ForEach @entry in (@methodPropertyTable)    
      @requiredBinVersion = @entry[3];
      if (@binVersion >= @requiredBinVersion) then
        @propertyList = InsertValue(@propertyList, @entry[1]);
      endif
    Next
    @methodDefinitionSet = @class\$MethDef.@propertyList;

    forEach @method in (@methodDefinitionSet)
      @methodName = @method.$MethNameIntern;
      @methodId = @method.$MethId;
      @methodImplName = @method.$ImplementationName;
      // append method ID as suffix to filename if there are multiple methods with same internal name
      @isMethodNameUnique = (Count(@methodDefinitionSet\$Subset(*:.$MethNameIntern==@methodName).$MethNameIntern)<=1);
      @methodNameSuffix = "";
      if (!@isMethodNameUnique) then
        @methodNameSuffix = @methodIdSeparator + @hexIdPrefix + format(@hexFormatString,@methodId);
      endif

      // process method properties     
      forEach @entry in (@methodPropertyTable)
        @requiredBinVersion = @entry[3];
        if (@binVersion >= @requiredBinVersion) then
          @methodPropertyNameIntern  = @entry[1];
          @methodPropertyNameVisible = @entry[2];
          @content = @method.@methodPropertyNameIntern;
          if (Left(@content,4) like 'PQL:') then
            @content = Right(@content,Length(@content)-4);          
            @fileName = @classPrefix + @className + @classMethodSeparator + @methodName + @propertySeparator + 
              @methodPropertyNameVisible + @methodNameSuffix + @fileNameAppendix + @FILE_EXTENSION_PQL;
            @codeExportTableEntry = {'PQL', @fileName,@content,""}; 
            @codeExportTable = InsertValue(@codeExportTable,@codeExportTableEntry);
          endif;
        endif;
      next
      
      // process PqlExecute methods
      @isPqlExecuteMethod = (@methodImplName like 'PqlExecute*' AND @method.$Paramcount>0); // PqlExecute methods need at least one parameter
      if (!@isPqlExecuteMethod) then
        next; // jump to next method
      endif
      
      // loop through method params (last param that starts with "PQLStatement=" is executed by system)
      @idxParam = 1;
      @pqlStatement = "";
      @pqlParamHeaderInfo = "";
      while (@idxParam <= count(@method.$Param))
        @currentParam = @method.$Param[@idxParam];
        if (Left(@currentParam,length(@PQLPARAMPREFIX)) like @PQLPARAMPREFIX) then
          @pqlStatement = @currentParam;
        else
          // all params that do not contain PQL code are printed in header information
          @pqlParamHeaderInfo += ' *      Param'+@idxParam+': '+@method.$Param[@idxParam]+@CR; 
        endif
        @idxParam++;
      next
      @pqlParamHeaderInfo = left(@pqlParamHeaderInfo, Length(@pqlParamHeaderInfo)-1);

      if (@pqlStatement=="") then
        message(@MSG_WARNING,'PqlExecute method "'+@methodName+'" of class '+@className+' has no PQLStatement defined.');
      else 
        @pqlStatement = Substitute(@pqlStatement, "PQLStatement=", "");
        //@pqlStatement = Substitute(@pqlStatement, 2*@PERCENT+"=", 5*@PERCENT+"="); // workaround for binariy versions <7.1 due to bug with percent signs  
        @pqlStatement = Substitute(@pqlStatement, 2*@PERCENT, @PERCENT);
        @pqlStatement = Substitute(@pqlStatement, @PERCENT+"=", "=");

        @fileHeader = '';
        if (@generatePqlHeader) then
         // generate header information
          @fileHeader += '/'+@STAR+@STAR+@CR;
          @fileHeader += ' *   CodeExport '+@VERSION+@CR;
          @fileHeader += ' *   2010-2013 by TimoP'+@CR;
          @fileHeader += ' *   File generated at '+DateTime()+' by '+$CurrentUserId.$name+''+@CR; 
          @fileHeader += ' *   ---'+@CR;
          @fileHeader += ' *   Visible Name:    '+@method.$MethNameVisible+@CR;
          @fileHeader += ' *   Internal Name:   '+@method.$MethNameIntern+@CR;
          @fileHeader += ' *   Description:     '+@method.$Description+@CR;

          ForEach @methodProperty in (@methodPropertyTable)
            @requiredBinVersion = @entry[3];
            if (@binVersion >= @requiredBinVersion) then
              @content = @method.@methodProperty[1];
              @content = Substitute(@content,@STAR+'/','* /'); 
              if (Left(@content,4) like 'PQL:') then
                @content = Right(@content,Length(@content)-4);
                @content = Substitute(@content, @CR, @CR+' *      ');  
                @content = @CR+' *      '+@content;            
              endif;
              @fileHeader += ' *   '+@methodProperty[2]+':  '+@content+@CR;
            endif;
          Next

          @fileHeader += ' *   Parameter:     '+@CR;
          if (@pqlParamHeaderInfo!="") then
            @fileHeader += @pqlParamHeaderInfo+@CR;
          endif
          @fileHeader += ' *'+@CR;
          @fileHeader += @STAR+@STAR+'/'+@CR+@CR;
        endif // (@generatePqlHeader)

        // add entry to codeExportTable
        @fileName = @classPrefix + @className + @classMethodSeparator + @methodName + 
          @methodNameSuffix + @fileNameAppendix + @FILE_EXTENSION_PQL;
        @codeExportTableEntry = {'PQL', @fileName,@pqlStatement,@fileHeader};
        @codeExportTable = InsertValue(@codeExportTable,@codeExportTableEntry);
      endif // @pqlStatement==""
      
      @fileHeader = '';
    next // @method in (@methodDefinitionSet)
  endif // (@export_PQL)


//===- Generate XML files from class definitions -===

  if (@export_XML) then

    // create XML header
    @xml_author  = $CurrentUserId.$name;
    @xml_date    = DateTime();
    @xml_HEADER = "";
    @xml_HEADER += '<?xml version="1.0" encoding="UTF-8" standalone="no" ?>'+@CR;
    @xml_HEADER += '<envelope>'+@CR;
    @xml_HEADER += @TAB+'<metadata>'+@CR;
    @xml_HEADER += 2*@TAB+'<version>';
    @xml_HEADER += @VERSION;
    @xml_HEADER += '</version>'+@CR;
    @xml_HEADER += 2*@TAB+'<author>';
    @xml_HEADER += @xml_author;
    @xml_HEADER += '</author>'+@CR;
    @xml_HEADER += 2*@TAB+'<date>';
    @xml_HEADER += @xml_date;
    @xml_HEADER += '</date>'+@CR;
    @xml_HEADER += @TAB+'</metadata>'+@CR;
    @xml_HEADER += @TAB+"<classList>"+@CR;

    // create XML trailer
    @xml_TRAILER = "";
    @xml_TRAILER += @TAB+"</classList>"+@CR;
    @xml_TRAILER += '</envelope>';

    if (@verboseLevel>2) then
      message(@MSG_INFO, ' -> Creating XML output for class "'+@className+'" ['+@class.$id+']  ('+@classIdx+' of '+@objectCountTable[@OBJECT_TYPE_CLASSES]+')');
    endif

    // create XML output for current class definition
    @classTreelevel = count (@class.$Inheritance)-2;
    @parentClassInternalName = @class\$AllParents($classes of *:).$InternalName top 1;

    @xmlData = '';
    @xmlData += @treelevel*@TAB+'<class ParentClass="'+@parentClassInternalName+'" TreeLevel="'+@classTreelevel+'">'+@CR;

    @executionMode            = @EXECUTION_MODE_DEFAULT;
    @currentMethodId          = $invalid;
    @idxLastProcessedFeature  = $invalid;
    @idxLastProcessedEntity   = $invalid;
    @idxLastProcessedProperty = $invalid;

    @idxFeature = 1;
    @abortLoop = false;

    while (@idxFeature<Count(@featureMappingTable)) // LOOP 1: class features (method list, attribute list, ...)

      if (@executionMode==@EXECUTION_MODE_METHOD_PARAMS) then
        @idxFeature = Count(@featureMappingTable); // ParamDef has to be last entry in table!
        @abortLoop = false;
      endif

      //message(@MSG_INFO, 'LOOP 1 >> feature '+@idxFeature+': '+@featureMappingTable[@idxFeature][1]);

      @classFeature                 = @featureMappingTable[@idxFeature][1];
      @classFeatureXmlParentTagName = @featureMappingTable[@idxFeature][2];
      @classFeatureXmlEntryTagName  = @featureMappingTable[@idxFeature][3];

      Select (@classFeature)
        Case 'ClassDef':
          @featurePropertyTable = @classMetadataTable;
          break;
        Case 'AttrDef':
          @featurePropertyTable = @attributeMetadataTable;
          break;
        Case 'MethDef':
          @featurePropertyTable = @methodMetadataTable;
          break;
        Case 'ParentDef':
          @featurePropertyTable = @parentDefMetadataTable;
          break;
        Case 'ChildDef':
          @featurePropertyTable = @childDefMetadataTable;
          break;
        Case 'StateDef':
          @featurePropertyTable = @stateDefMetadataTable;
          break;
        Case 'ParamDef':
          @featurePropertyTable = @paramDefMetadataTable;
      EndSelect

      @propertyList = Array();  
      ForEach @entry in (@featurePropertyTable)
        @requiredBinVersion = @entry[4];
        if (@binVersion >= @requiredBinVersion) then
          @propertyList = InsertValue(@propertyList, '$'+@entry[1]);
        endif
      Next

      Select (@classFeature)
        Case 'ClassDef':
          @featureProperties  = @class.@propertyList;
          break;
        Case 'AttrDef': 
          @featureProperties  = @class\$AttrDef.@propertyList;
          break;
        Case 'MethDef':
          @featureProperties  = @class\$MethDef.@propertyList; 
          break;
        Case 'ParentDef':
          @featureProperties  = @class\$ParentDef.@propertyList; 
          break;
        Case 'ChildDef':
          @featureProperties  = @class\$ChildDef.@propertyList; 
          break;
        Case 'StateDef':
          @featureProperties  = @class\$StateDef.@propertyList;
          break;
        Case 'ParamDef':
          @paramDefAttr = '$ParamDef';
          @featureProperties  = fromMem(@class\$MethDef(.$MethId==@currentMethodId).@paramDefAttr);
          // add column for 'DelegationAnchor' in case its missing
          @isParamDefIncomplete = Count(@featureProperties\$subset(*:.DelegationAnchor!=$invalid).InternalName)==0;
          if (@isParamDefIncomplete) then
            @featureProperties = @featureProperties\$subset.($invalid) as "DelegationAnchor",*;
          endif
      EndSelect
      @featurePropertiesCount = Count(@featureProperties);

      // restore index after method paramdef processing has finished
      if (@idxLastProcessedEntity && @executionMode == @EXECUTION_MODE_DEFAULT) then
        @idxEntity = @idxLastProcessedEntity;
        @idxLastProcessedEntity = $invalid;
      else
        @idxEntity = 1; 
        @treeLevel++;
        if (@classFeatureXmlParentTagName != "") then
          @xmlData += @treelevel*@TAB+"<"+@classFeatureXmlParentTagName+">"+@CR;
          @treeLevel++;
        endif    
      endif

      While (@idxEntity<=@featurePropertiesCount) // LOOP 2: single attribute, method, ...
 
        @attribute = @featureProperties[@idxEntity];
        if (@classFeature=='MethDef') then
          @currentMethodId = @attribute.$MethId;
        else
          @currentMethodId = $invalid;
        endif

        //message(@MSG_INFO, 'LOOP 2 >> entity (row) '+@idxEntity + ' --- '+format(@hexFormatString,@currentMethodId));

        // restore index after method paramdef processing has finished
        if (@idxLastProcessedProperty && @executionMode == @EXECUTION_MODE_DEFAULT) then
          @idxFeatureValues = ++@idxLastProcessedProperty; // jump to next property as ParamDef has been handled
          @idxLastProcessedProperty = $invalid;
        else
          @idxFeatureValues = 1;  
          @xmlData += @treelevel*@TAB+"<"+@classFeatureXmlEntryTagName+">"+ @CR;       
        endif   
        @treeLevel++;

        While (@idxFeatureValues <= (count(@featurePropertyTable))) // LOOP 3: properties
 
          //message(@MSG_INFO, 'LOOP 3 >> property '+@idxFeatureValues+': '+@featurePropertyTable[@idxFeatureValues][1]);

          @property = @featurePropertyTable[@idxFeatureValues][1];
          // for method params processing, exit loop and store current index to return later
          if (@property==@METHOD_PARAMS_PROPERTY_NAME AND @classFeature=='MethDef') then
            @idxLastProcessedProperty = @idxFeatureValues;
            @executionMode = @EXECUTION_MODE_METHOD_PARAMS;
            @abortLoop = true;
            break; // go back to method loop (as $ParamDef is only defined in the context of a method)
          endif

          @propertyIsArray = @featurePropertyTable[@idxFeatureValues][2];       
          @propertyEncode  = @featurePropertyTable[@idxFeatureValues][3];
          @propertyPrefix = '$';
          if (@executionMode==@EXECUTION_MODE_METHOD_PARAMS) then
            @propertyPrefix = '';
          endif
          @propertyDollar  = @propertyPrefix+@property;
          @propertyValue   = @attribute.@propertyDollar;

          if (InArray({'AttrId','MethId','RefId','SortIndex'}, @property)) then
            @propertyValue = @hexIdPrefix + format(@hexFormatString,@propertyValue);
          endif          
          @attrPropertyEntryCount = count(@propertyValue);

          // quick exit for empty scalar values
          if (!@propertyIsArray AND (@attrPropertyEntryCount==0 OR ToString(@propertyValue)=='')) then
            @xmlData += @treelevel*@TAB+'<'+@property+'></'+@property+'>'+@CR;
            @idxFeatureValues++;
            next;
          endif

          // ignore strange entries like "/@$!#0076f#ID" in privilege array
          if (@property like '*Privileges') then
            if (@attrPropertyEntryCount>0 && left(@propertyValue[@attrPropertyEntryCount],2)!='$_') then
              @attrPropertyEntryCount--;
            endif
          endif

          @arrayIndex = 1;
          @arrayXmlTagPropertyString = '';

          While (@arrayIndex <= @attrPropertyEntryCount)
            @propertyValueOrig = tostring(@propertyValue[@arrayIndex]);
            @propertyValueNew = @propertyValueOrig;
            @len_AttrPropertyValue = length(@propertyValueOrig);
                           
            if (@propertyIsArray) then
               @arrayXmlTagPropertyString = ' idx="'+@arrayIndex+'"';
            endif


            // quick exit for empty values
            if (ToString(@propertyValueOrig)=='' OR @propertyValueOrig==$invalid) then
              @xmlData += @treelevel*@TAB+'<'+@property+@arrayXmlTagPropertyString+'></'+@property+'>'+@CR;
              @arrayIndex++;
              next;
            endif


            // check if attribute property value has to be encoded or otherwise tranformed
            if (@propertyEncode==1) then
               @propertyValueNew=Base64Encode(@propertyValueNew,@xml_base64charsPerLine);
              @propertyValueNew=Left(@propertyValueNew, Length(@propertyValueNew)-1);
            elseif (@propertyEncode==2) then
              @objref=@propertyValueNew;
              @propertyValueNew=@objref.$logicalguid;
            endif
            
            // check if we want a XML comment for this attribute property
            @generateXmlComment = (@xmlComments AND @propertyEncode);// AND (@propertyValueNew!=''));
            @multiLine = (length(@propertyValueNew) > @xml_base64charsPerLine) OR @generateXmlComment;      
            if (@generateXmlComment) then
              @propertyValueComment = @propertyValueOrig;
              @propertyTableIndex = Toint(@propertyValueOrig);
              If (@propertyTableIndex==$Invalid) Then 
                @propertyTableIndex = 0; 
              EndIf
              Select (@propertyEncode)
                Case 0: break;
                Case 3:
                  if (@propertyTableIndex<=Count(@attrTypeTable)) then
                    @propertyValueComment = @attrTypeTable[@propertyTableIndex];
                  endif
                  break;
                Case 4:
                  if (@propertyTableIndex<=Count(@transEventTypeTable)) then
                    @propertyValueComment = @transEventTypeTable[@propertyTableIndex+1];
                  endif
                  break;
                Case 5:
                  @propertyValueComment = @class\$StateDef(.$StateId==@propertyTableIndex).$StateNameVisible;
                  break;
                Case 6:
                  if (IsObjRef(@propertyValue) AND @propertyValue!=0.0.0.ffff) then
                    @propertyValueComment = @attribute\@propertyDollar.$name;
                  endif
                  break;
                Case 7:
                  if (@propertyTableIndex<=Count(@classUsageTable)) then
                    @propertyValueComment = @classUsageTable[@propertyTableIndex+1];
                  endif
                  break;
              EndSelect
              
              // special handling for XML comments containing PQL code
              @idx_PropertyPrefixPQLTable = 1;
              @propertyContainsPQL = 0;
              While (@idx_PropertyPrefixPQLTable <= @propertyPrefixPQLTableCount)
                @propertyPrefixPQL = @propertyPrefixPQLTable[@idx_PropertyPrefixPQLTable];
                @idx_PropertyPrefixPQLTable++;
                @len_PropertyPrefixPQL = length(@propertyPrefixPQL);        
                if (Left(@propertyValueOrig, @len_PropertyPrefixPQL) like @propertyPrefixPQL) then
                   @propertyContainsPQL = 1;
                   @propertyValueComment = Right(@propertyValueOrig, (@len_AttrPropertyValue - @len_PropertyPrefixPQL));
                   @propertyValueComment = Substitute(@propertyValueComment, @PERCENT+'=', '=');
                   break;
                endif
              Next 

              // replace all "--" strings in comment as it would be treated as the end of the XML comment
              @xmlSpacePqlProperty = '';
              if (@propertyContainsPQL) then
                @xmlSpacePqlProperty = @CR;
              endif

              @propertyValueComment = @xml_commentPrefix+@xmlSpacePqlProperty+substitute(@propertyValueComment,"--",@xml_minusminusReplacement)+@xmlSpacePqlProperty+@xml_commentSuffix; 
            else
              @propertyValueComment = '';
            endif               
            
            @xmlTagLineEnd = '';
            @xmlTagLineEndComment ='';
            @newIndent = '';
            @xmlSpaceTagClose = '';          
            if (@multiLine) then
              @xmlTagLineEnd = @CR;
              @newIndent = (@treelevel+1)*@TAB;
              @xmlTagLineEndComment = @CR;
              @xmlSpaceTagClose = @CR + @treelevel*@TAB;
            endif

            @line = @treelevel*@TAB+
                    '<'+@property+@arrayXmlTagPropertyString+'>'+@xmlTagLineEnd+
                    @newIndent+@propertyValueComment+@xmlTagLineEndComment+
                    @newIndent+@propertyValueNew+@xmlSpaceTagClose+
                    '</'+@property+'>'+@CR;

            @xmlData += @line;
            @arrayIndex++;
          next // @arrayIndex <= @attrPropertyEntryCount
        
          @idxFeatureValues++;
        next // @idxFeatureValues<(count(@featurePropertyTable)+1) // ### END LOOP 3 ###

        // for method paramdef processing, exit loop and store current index to return later
        if (@abortLoop) then
          @idxLastProcessedEntity = @idxEntity;
          break; // go back to main loop for class features
        endif

        @treeLevel--;
        @xmlData += @treelevel*@TAB+"</"+@classFeatureXmlEntryTagName+">" + @CR;
        @idxEntity++;
      next // @idxEntity<=Count(@featureProperties) // ### END LOOP 2 ###

      @treeLevel--;
 
      // for method paramdef processing, exit loop and store current index to return later
      if (@abortLoop) then     
        @idxLastProcessedFeature = @idxFeature;
        next;
      endif

      if (@classFeatureXmlParentTagName != "") then
          @xmlData += @treelevel*@TAB+"</"+@classFeatureXmlParentTagName+">" + @CR;
         @treeLevel--;
      endif

      // at this point, method paramdef processing is finished and so we switch back to normal processing mode and continue with next property 
      if (@executionMode == @EXECUTION_MODE_METHOD_PARAMS) then
        @idxFeature = @idxLastProcessedFeature;
        @executionMode = @EXECUTION_MODE_DEFAULT;
      else
        @idxFeature++;
      endif  
    next // @idxFeature<count(@featureMappingTable) // ### END LOOP 1 ###
    @xmlData += @treelevel*@TAB+'</class>'+@CR;
    @classDuplicateSuffix = '';
    if (@isDuplicateClass) then 
      @lguid = ToString(@class.$LogicalGUID);
      @lguid = SubStr(@lguid, 2, Length(@lguid)-2);
      @classDuplicateSuffix = @methodIdSeparator + @lguid;
    endif
    @classNameXml = @class.$internalname + @fileNameAppendix + @classDuplicateSuffix + @FILE_EXTENSION_XML;
    @codeExportTableEntry = Array('XML', @classNameXml, @xmlData, "");
    @codeExportTable = InsertValue(@codeExportTable, @codeExportTableEntry);
    if (@xmlCreateCombinedOutputFile) then
      @xmlDataCombined += @xmlData;
    endif
  endif; // @export_XML
  @classIdx++;
next  // @class in (@classSet) 



//===- save PQL code of templates and instances in CodeExportTable -===

if (@export_PQL) then
  @instancePqlCount = 0;
  @templatePqlCount = 0;
  @objSetToExport = union(@instanceSetToExport, @templateSetToExport);
  forEach @obj in (@objSetToExport)
    @objType    = @obj.$objType;
    @objId      = @obj.$id;
    @objName    = @obj.$displayname;
    @objLguid   = @obj.$Logicalguid;
    @objVguid   = @obj.$VersionGUID;
    @objCreator = @obj\$author.$name;
    if (@objCreator==$invalid) then
      @objCreator = "$ISIS$";
    endif
    @className  = @obj\$classGUID.$internalname;
    @creationDate     = Substitute(ToString(date(@obj.$Created)),"/","")+@dateTimeSeparator+Substitute(ToString(time(@obj.$Created)),":","");
    @modificationDate = Substitute(ToString(date(@obj.$Modified)),"/","")+@dateTimeSeparator+Substitute(ToString(time(@obj.$Modified)),":","");
    if (@objType==@OBJECT_TYPE_INSTANCES) then
      @filenameNs = @instanceNamingScheme;
    else
      @filenameNs = @templateNamingScheme;
    endif
   
    // supported variables: <OID>, <LGUID>, <CLASS_NAME>, <OBJ_NAME>, <DATE_CREATED>, <DATE_MODIFIED>, <CREATOR>, <ATTR_NAME>
    // example naming scheme: (T)<CLASS_NAME>_-_<OBJ_NAME>_<ATTR_NAME>_<LGUID>_<OID>
    @filenameNs = Substitute(@filenameNs, '<OID>',           toString(@objId));
    @filenameNs = Substitute(@filenameNs, '<LGUID>',         toString(@objLguid));
    @filenameNs = Substitute(@filenameNs, '<VGUID>',         toString(@objVguid));
    @filenameNs = Substitute(@filenameNs, '<CLASS_NAME>',    @className);
    @filenameNs = Substitute(@filenameNs, '<OBJ_NAME>',      @objName); 
    @filenameNs = Substitute(@filenameNs, '<DATE_CREATED>',  @creationDate);      
    @filenameNs = Substitute(@filenameNs, '<DATE_MODIFIED>', @modificationDate);
    @filenameNs = Substitute(@filenameNs, '<CREATOR>',       @objCreator);   

    // if whole version chain is exported and filename doesn't contain creation date yet, then add timestamp to filename
    @filenameAppendix = '';
    if (@includeVersionChain) then
      if (Pos('<OBJ_CREATEDATE>', @filenameNs)==0) then
        @filenameAppendix = @filenameComponentSeparator + @creationDate;
      endif
    endif  
    @pqlAttrSet  = @obj\$inheritance\$attrdef(.$EditMode like @EDITMODE_PQLSTATEMENT).$attrnameintern groupBy $attrnameintern;
    @pqlAttrList = ToArray(@pqlAttrSet);
    @obj = @obj\$Reload(*:).@sysattrList,@pqlAttrList;
    forEach @attr in (@pqlAttrSet)
    
      @attrName = @attr.$attrnameintern;
      @pqlStatement = @obj.@attr;
      @pqlStatementLen = length(@pqlStatement);
      @filename = Substitute(@filenameNs, '<ATTR_NAME>', @attrName);
      @filename += (@filenameAppendix + @FILE_EXTENSION_PQL);
      forEach @char in (@FILENAME_FORBIDDEN_CHARS)
        @filename = Substitute(@filename, @char, @invalidCharReplacement);
      next

      if (@pqlStatementLen>0) then
        @codeExportTableEntry = array('PQL', @filename, @pqlStatement, '');
        @codeExportTable = insertValue(@codeExportTable,@codeExportTableEntry);
        if (@objType==@OBJECT_TYPE_INSTANCES) then
          @instancePqlCount++;
        else
          @templatePqlCount++;
        endif
      endif  
    next
  next
endif



//===- Check code based on regular expressions -===

if (@performCodeCheck) then
  if (@verboseLevel > 0) then
    message(@MSG_INFO, '');
    message(@MSG_INFO,'*** Checking code based on regular expressions ***');
    message(@MSG_INFO, '');
  endif
  ForEach @codeExportTableEntry in (@codeExportTable)

    @fileType = @codeExportTableEntry[1];
    @fileName = @codeExportTableEntry[2];
    @contentToAnalyse = "";
    Select @fileType
      Case 'DFA':
        @fileHandle = FileOpen(@codeExportTableEntry[4], 'CONTENT', 'r');
        @contentToAnalyse = FileReadString(@fileHandle, -1);
        @rc = FileClose(@fileHandle);
        break;
      Case 'PQL':
        @contentToAnalyse = @codeExportTableEntry[3];
        break;
      Case 'XML':
        break;
    EndSelect

    ForEach @searchExpressionsEntry in (@searchExpressions)
      @regEx = @searchExpressionsEntry[1];
      @regExMsg = @searchExpressionsEntry[2];
      @charsBefore = @searchExpressionsEntry[3];
      @charsAfter  = @searchExpressionsEntry[4];
      @lineNumber=0;
      @pos_global = 1;
      @match = RegExpMatch(@contentToAnalyse,@regEx);
      @lines = split(@contentToAnalyse,@CR);
      @inputString = @contentToAnalyse;
      if (count(@match)>0) then
        if (@verboseLevel > 0) then  
          message(@MSG_INFO,' -> File: "'+@fileName+'"');
        endif
      endif

      while (count(@match)>0)
        @pos_global = pos(@match[1],@contentToAnalyse,@pos_global);
        @charsBefore = @searchExpressionsEntry[3];
        @charsAfter  = @searchExpressionsEntry[4];
    
        @prefixCode=left(@contentToAnalyse,@pos_global);
        // determine line number by counting linebreaks (CR)
        @lineNumber=length(@prefixCode)-length(substitute(@prefixCode,@CR,""))+1;
    
        @line = @lines[@lineNumber];
        @pos_line = pos(@match[1],@line);
          
        if (@pos_global<=@charsBefore) then @charsBefore = @pos_global-1; endif
        if (@pos_global+length(@match[1])+@charsAfter>Length(@contentToAnalyse)) then 
          @charsAfter = (Length(@contentToAnalyse) - @pos_global-length(@match[1])+1); 
        endif
             
        @line = SubStr(@contentToAnalyse,@pos_global-@charsBefore,@charsBefore+length(@match[1])+@charsAfter);
        @line = Substitute(@line,@CR,' ');
        if (@verboseLevel > 0) then
          message(@MSG_INFO,"    Found "+@regExMsg+ " in line "+@lineNumber+", position "+ @pos_line);
          if (@verboseLevel > 1) then
            message(@MSG_INFO,'    "...'+@line+'..."');
          endif
        endif
        
        // if code fragment contains semicolon (standard field delimiter for CSV) then mask field using "excel" agorithm
        @needsMasking = Pos(';',@line);
        if (@needsMasking) then
          @line = '"' + Substitute(@line, '"', '""') + '"';
        endif

        //@codeCheckMessageTable structure: 'FILENAME;LINE;POSITION;MESSAGE_TYPE;CODE_CONTEXT';
        @codeCheckMessageTableLine = 
          @fileName + @codeCheckSeparator + @lineNumber + @codeCheckSeparator + @pos_line + @codeCheckSeparator + @regExMsg + @codeCheckSeparator + @line;
        @codeCheckMessageTable = @codeCheckMessageTable + @codeCheckMessageTableLine + @CR;
        @codeCheckMessageCount++;          

        @pos_global = @pos_global + length(@match[1]);
        @inputString = SubStr(@inputString, @pos_global, (Length(@contentToAnalyse)-@pos_global));
        @match = RegExpMatch(@inputString,@regEx);
      next // (count(@match)>0)
    next  // @searchExpressionsEntry in (@searchExpressions)
  next  // @codeExportTableEntry in (@codeExportTable)
endif // (@performCodeCheck)




//===- Export code to filesystem -===

if (@verboseLevel > 0) then
  message(@MSG_INFO, '');
  message(@MSG_INFO,'*** Export files to '+@exportPath+' ***');
  message(@MSG_INFO, '');
endif
@FLAG_CREATE_MISSING_DIR = 1;
@binaryExportFlags = @FLAG_CREATE_MISSING_DIR;

forEach @codeExportTableEntry in (@codeExportTable)

  @fileType = @codeExportTableEntry[1];
  Select @fileType
      Case 'DFA':
        @obj = @codeExportTableEntry[4];
        if (toString(@obj.Content)=='') then
          message(@MSG_WARNING,' The following resource has no binary content: '+ @obj.$name +'.');
        else
          @objCountDFA++;
          @fileName = @codeExportTableEntry[2];
          @exportSuccessful = 1;
          if (@simulateExport==false) then
            if (@isBinExpExtSupported) then
              $local($ie):@rc = @obj.@exportMethodRcResource('CONTENT',@exportPath+@exportFolderDFA+@dirSeparator+@fileName,$Invalid,$Invalid,$Invalid,@binaryExportFlags);
            else
              $local($ie):@rc = @obj.BinaryExport('CONTENT',@exportPath+@exportFolderDFA+@dirSeparator+@fileName);
            endif
            if (@rc != 0) then     
              @exportSuccessful = 0;
              @objCountDFA--;
              message(@MSG_INFO,'     ERROR: '+ @fileName +' could not be exported');
            endif
          endif // (@simulateExport==false)
          if ((@verboseLevel > 0) && (@exportSuccessful)) then 
            message(@MSG_INFO,' -> File '+ @fileName +' was exported successfully');
          endif                  
        endif
        break;
      Case 'PQL':
      Case 'XML':
        if (@fileType=='PQL') then
          @objCountPQL++;
          @exportFolder = @exportFolderPQL;
        elseIf (@fileType=='XML') then
          @objCountXML++;
          @exportFolder = @exportFolderXML;
        endif
        @fileName = @codeExportTableEntry[2];
        @exportSuccessful = 1;
        if (@simulateExport==false) then    
    
          // write PQL statement into binary attribute of export tool
          @fileHandle = FileOpen(@exportTool.$id,'TargetName','w');
          @fileHeader = @codeExportTableEntry[4];
          @pqlStatement = @codeExportTableEntry[3];
      
          @fileHandle.$FileWrite(@fileHeader);
          @fileHandle.$FileWrite(@pqlStatement);
          @fileHandle.$FileClose();
    
          // write binary attribute to file
          if (@isBinExpExtSupported) then
            $local($ie):@rc = @exportTool.@exportMethodData('TargetName',@exportPath+@exportFolder+@dirSeparator+@fileName,$Invalid,$Invalid,$Invalid,@binaryExportFlags);
          else
            $local($ie):@rc = @exportTool.BinaryExport('TargetName',@exportPath+@exportFolder+@dirSeparator+@fileName);
          endif
          if (@rc != 0) then
            @exportSuccessful = 0;
            if (@fileType=='PQL') then
              @objCountPQL--;
            elseIf (@fileType=='XML') then
              @objCountXML--;
            endif
            message(@MSG_INFO,' ERROR: '+ @fileName +' could not be exported');  
          endif  
        endif // (@simulateExport==false)
        if ((@verboseLevel > 0) && (@exportSuccessful)) then 
          message(@MSG_INFO,' -> File '+ @fileName +' was exported successfully');
        endif 
        break;
    EndSelect
next // @line in (@codeExportTable)

// export combined XML data to filesystem
if (@simulateExport==false) then
  if (@export_XML AND @xmlCreateCombinedOutputFile AND @xmlDataCombined != "") then
    @fileName   = @exportPath + @exportFolderXML + @dirSeparator + @xmlCombinedOutputFilename;
    @xmlData    = @XML_HEADER + @xmlDataCombined + @XML_TRAILER;
    @fileHandle = FileOpen(@exportTool.$id,'TargetName','w');
    @fileHandle.$FileWrite(@xmlData);
    @fileHandle.$FileClose();
    // at this point, XML folder should have been created, so no need for "BinaryExportExtended" 
    @rc = @exportTool.BinaryExport(@exportToolBinAttrName,@fileName);
    if (@rc==0) then
      if (@verboseLevel > 1) then
        message(@MSG_INFO, ' -> Combined XML file has been exported to "'+ @fileName+'"');
        @objCountXML++;
      endif
    endif
  endif
endif

// export code-check messages to filesystem
@fileName = @exportPath+@exportFileCodeCheck;
if (@simulateExport==false) then
  if (@codeCheckMessageCount>0) then
    @fileHandle = FileOpen(@exportTool.$id,'TargetName','w');
    @fileHandle.$FileWrite(@codeCheckMessageTable);
    @fileHandle.$FileClose();
    // this file goes into root folder, so no need for "BinaryExportExtended"
    $local($ie):@rc = @exportTool.BinaryExport('TargetName',@fileName);
    if (@rc == 0) then
      if (@verboseLevel > 1) then
        message(@MSG_INFO,' -> Code checker message file has been exported to "'+ @fileName +'"');
      endif
    else
      message(@MSG_INFO,' ERROR: '+ @fileName +' could not be exported');  
    endif
  endif
endif // (@simulateExport==false)


//===- Print summary -===

@simulationMessage = "";
@codeCheckMessage = "";
if (@simulateExport) then
    @simulationMessage = ' [Simulation mode is ON, no files are physically exported.]';
endif
if (@performCodeCheck) then
  @codeCheckMessage = ' '+ Right(toString(@codeCheckMessageCount),5,' ') + ' matches found by code checker. Log saved to '+@exportPath+@exportFileCodeCheck;
endif  
if (@verboseLevel > 0) then
  message(@MSG_INFO, '');
  message(@MSG_INFO, '');
  message(@MSG_INFO, '*** SUMMARY ***' + @simulationMessage);
  message(@MSG_INFO, '------------------------------------------------------------------------------------------------');
  message(@MSG_INFO,' '+ Right(toString(@objCountPQL),5,' ') + ' PQL files exported to '+@exportPath+@exportFolderPQL);
  if (@export_PQL && (@objectCountTable[@OBJECT_TYPE_TEMPLATES]>0 || @objectCountTable[@OBJECT_TYPE_INSTANCES]>0)) then
  message(@MSG_INFO,' '+ '      (including ' + @instancePqlCount + ' PQLs from instances and '+@templatePqlCount+' PQLs from templates)');
  endif
  message(@MSG_INFO,' '+ Right(toString(@objCountDFA),5,' ') + ' DocDef/Include files exported to '+@exportPath+@exportFolderDFA);
  message(@MSG_INFO,' '+ Right(toString(@objCountXML),5,' ') + ' XML files exported to '+@exportPath+@exportFolderXML);
  message(@MSG_INFO, @codeCheckMessage);
  message(@MSG_INFO, '================================================================================================');
  message(@MSG_INFO, ''); 
endif // (@verboseLevel > 0)

@objCountExported = @objCountPQL + @objCountDFA;
return @objCountExported;


// P.S.: never write PQLs longer then 50 lines