/*
 *    .d8888b.                888          8888888888                                    888
 *   d88P  Y88b               888          888                                           888
 *   888    888               888          888                                           888
 *   888         .d88b.   .d88888  .d88b.  8888888    888  888 88888b.   .d88b.  888d888 888888
 *   888        d88""88b d88" 888 d8P  Y8b 888        `Y8bd8P´ 888 "88b d88""88b 888P"   888
 *   888    888 888  888 888  888 88888888 888          X88K   888  888 888  888 888     888
 *   Y88b  d88P Y88..88P Y88b 888 Y8b.     888        .d8""8b. 888 d88P Y88..88P 888     Y88b.
 *    "Y8888P"   "Y88P"   "Y88888  "Y8888  8888888888 888  888 88888P"   "Y88P"  888      "Y888
 *                                                             888
 *                                                             888
 *                                                             888        v4.50
 *                                                             
 * created by TimoP, initial version released 03/2010, 
 * credits to RalfH / ManfredG / MarcoP for some nice ideas and testing
 *
 * 
 * Desciption:
 * This script exports PQL code from a defined set of objects and DOCDEF code from a defined set of resources to the
 * local filesystem. PQL code can be extracted from classes, templates or instances which are specfied by an array of
 * export definitions like "T:<PQL>CF3*" which would export all PQL code from templates of type PQL whose name starts 
 * with "CF3". DOCDEF code is extracted from either DFA or INC resources that can be specified by wildcard definitions 
 * like "CF3*" or by fix names.
 * In addition a code check can be performed to e.g. find print statements or hardcoded object IDs.
 * The code checking is done via a list of pre-defined regular expressions and can be easily extended.
 * The script can be adjusted via a couple of variables in section "Configuration" below. 
 * It returns the number of exported objects.
 * 
 * Notes: 
 * - script has to run on a local node running under windows 
 * - for better readability, your kernel window size should have a width of at least 180 characters.
 * 
 * History:
 *   v1.0: initial version
 *   v1.1: some minor fixes
 *   v1.2: 
 *       - minor fixes
 *       - DataGenericBinary is searched directly underneath node object
 *       - data object is removed if it was created by script
 *   v1.3:
 *       - new feature: warnings for hardcoded OIDs in PQL code
 *       - ignore "empty" PQLExecute methods (e.g. material methods)
 *       - use "like" instead of "upper()" to compare method name with "PQLEXECUTE"
 *       - verbose mode switch 
 *   v1.4:
 *       - filenames are suffixed by method ID in hex in case several methods have the same internal name
 *       - if paramcount > 1 then PQLCode is taken from last param containing a PQL statement
 *       - exportPath is extended by a backslash if missing
 *       - display line number in warnings
 *   v1.5:
 *       - header information for PQL-methods is written into output file (description, pre-constraints, visible name, params, ...)
 *       - small corrections
 *   v1.6: 
 *       - improved message system (support for additional types of warnings)
 *       - data object is always created (and removed)
 *       - simulation mode (only kernel output, no filesystem export)
 *       - possibility to define a fixed set of classes/objects to export (e.g. if there is no common prefix)
 *   v1.7:
 *       - support for PQL code defined in attr/method properties like "pre conditions" etc.
 *       - code refactoring
 *   v1.8:
 *       - export to subdirectory with current datestamp
 *       - optimized code checking
 *   v1.9:
 *       - separate subdirectories for DFA, PQL and (in the future) XML files for class definitions
 *       - user defined classes can be added to classes specified via prefix
 *       - fixed bug where batch file (= output folders) is only created when PQL export is activated
 *       - improved messages
 *       - check if resources have binary content
 *       - instantiate helper objects transient (in memory)
 *   v2.0:
 *       - export code-check messages to CSV file
 *       - code refactoring
 *       - code checking for DFA
 *       - possibility to define classes to exclude from export 
 *       - updated regex defintions for code checker
 *       - message command used instead of print
 *       - do not create output folders if there are no files
 *   v2.1 
 *       - fixed bug where CSV file is not written
 *       - updated regex table
 *       - added toggle for header sections in PQL methods 
 *       - added support for PQL code in $Substitution properties
 *   v2.2
 *       - new setting to export all versions of a class:  @includeVersionChain
 *       - support for class duplicates after TRF import with option "allow import of different class with same internal name" 
 *   v2.3
 *       - added parameter interface that allows to call this script from external, e.g. to use it in custom tool class    
 *   v3.0:
 *       - export of class definitions in XML format
 *   v3.0.2:
 *       - improved check for valid resources by looking for string "$$Binary$$" in attribute 
 *       - improved search for PqlExecute methods by using filter "PqlExecute*" (to take also "PqlExecuteWithoutEvent" methods into account)
 *   v3.1:
 *       - fixed bug where $substitution property was not exported correctly
 *       - added index to filenanmes for multivalue attribute properties 
 *   v3.2:
 *       - API extension: search expression for code checker can be defined externally (one at a time) which will override built-in regex definitions
 *   v3.3:
 *       - separators for output filenames are now configurable
 *   v3.5:
 *       - support for PQL code export from templates and instances
 *       - redesigned interface (API) for external calls to support more parameters 
 *   v3.6:
 *       - fixed support for complete version chain export (renamed parameter to "Include Version Chain")
 *       - attribute, method and parent/child IDs are output in hex format (only stateID remains decimal) 
 *       - added class/template internal name to filenames for instances and templates
 *       - extended interface with two new settings "CodeExportMethodIdSeparator" and "CodeExportClassObjNameSeparator"
 *   v3.6.1:
 *       - bugfix: corrected handling for percent signs in PQL code during export 
 *       - bugfix: corrected DFA file names
 *   v3.7:
 *       - PQL statements from material methods are now exported  
 *       - SortIndex property is written in hex format
 *       - fixed bug where methodIDs were appended to filename unnecessarily
 *       - timestamp added to filenames if option "IncludeVersionChain" is on
 *   v3.8:
 *       - introduced template / instance file naming scheme so users can define filenames in a more flexible way
 *   v3.9:
 *       - use internal function "BinaryExportExtended" for file export if supported
 *       - minor code / performance improvement in method export loop
 *       - bugfix: duplicate method names are now handled correctly (filenames will be suffixed by methodID)
 *       - bugfix: combined XML file was not created properly before
 *       - bugfix: file counters are only increased when export was successful (in case or simulation is OFF)
 *   v4.0:
 *       - added support for new system attributes / properties: $Abstract, $Final, $Delegate, $Accessibility  
 *       - added mapping between system attributes and binary versions for backward compatibilty
 *   v4.1:
 *       - extended XML comments to support visible names for OID properties (e.g. $Author), $TransTargetState and $TransEventTypes
 *       - write user-defined search string for code checks to header line of CSV file (if available)
 *       - empty properties are now always exported into XMLs and properly formatted 
 *   v4.5:
 *       - added method parameter definitions ($ParamDef) to XML output
 *       - changed message codes (I/W/E) to be independent of EYE FW
 *
 *
 *   
 *   Known issues (will not affect functionality)
 *   - on systems, where "BinaryExportExtended" is not supported, the output directories are created by a batch script 
 *     which has following drawbacks:
 *     - ExternalApplication tool is instantiated in same transaction which leads to warning messages "POTR0035W Object ... not found" (Can be avoided using $transaction() in v7.1)
 *     - Batch file doesn't set errorcode of 0 which leads to error message like "POTR0056E External process 'D:\CodeExport\codeexport.bat' ended with RC=1(1)"
 *   - invalid characters in XML comments are not handled, e.g. german umlauts in attribute descriptions 
 */


//====BEGIN_CONFIGURATION=========================================================================================================================
Option ExecutionFlags = $io, $im;

// Basic settings
// (number in square brackets shows to which parameter the variable corresponds when script is called from external)
@exportDefinitionsPql       = Array();  // [1] set of classes and/or templates and/or instances for PQL export
@exportDefinitionsResources = Array();  // [2] set of DFAs/INCs that will be exported
@exportPathBase = "C:\CodeExport\";     // [3] output folder path (a new subfolder will be created within this folder each time the script runs)
@export_PQL = true;                     // [4.1] switch to toggle export of PQL code
@export_DFA = true;                     // [4.2] switch to toggle export of DFAs / INCs
@export_XML = true;                     // [4.3] switch to toggle export of class definitions in XML format
@simulateExport   = true;               // [5.1] if set to 1, no files are generated, e.g. if if you only want to perform code check
@performCodeCheck = true;               // [5.2] defines whether a code check should be done (based on regular expressions)
@verboseLevel = 2;                      // [8] verbose level, set to 0 for quiet operation
     
// Advanced settings
@generatePqlHeader   = true;            // [5.3] defines whether a header section is added to each file that contains code of a PQL method 
@includeVersionChain = false;           // [5.4] defines if all versions of a class should be exported (1) or just the latest one (0)
@xmlComments         = true;            // [5.5] set to 1 for human readable output of B64 encoded content and attribute types 
@xmlCreateCombinedOutputFile = true;    // [5.6] set to 1 to create a combined XML file for all classes in addition to single output files
@classPrefix             = '';          // [7.1] prefix for all output files that contain PQL code from classes
@classAttributeSeparator = '_';         // [7.2] separator between class and attribute name in output filename
@classMethodSeparator    = '_-_';       // [7.3] separator between class and method name in output filename
@propertySeparator       = '_$';        // [7.4] separator between attribute/method name and property name in output filename
@propertyIndexSeparator  = '.';         // [7.5] separator between property name and index in output filename (only applied if propery is an array, e.g. $substitution)
@methodIdSeparator       = '_';         // [7.6] separator between method name and method ID (only applied if there are multiple methods with the same name)
@templateNamingScheme    = '(T)<CLASS_NAME>_-_<OBJ_NAME>_<ATTR_NAME>_<OID>'; // [7.7] naming scheme for templates
@instanceNamingScheme    = '(I)<CLASS_NAME>_-_<OBJ_NAME>_<ATTR_NAME>_<OID>'; // [7.8] naming scheme for instances
@invalidCharReplacement  = '_';         // [7.9] replacement character(s) for invalid characters in instance/template names



// [6] Regular expression table used during code checking
// [regex] | [message] | [num chars to print before match] | [num chars to print after match] 
@searchExpressions = Array(
  {'[\\="' + "'{,][\s]*[0-9A-Fa-f]{1,3}\.[0-9A-Fa-f]{1,3}\.[0-9A-Fa-f]{1,8}\.[0-9A-Fa-f]{1,8}[\s]*[\\'" + '"};,] ', "hardcoded object ID", 32, 32},
  {"\$[1-9A-Fa-f]+[:(]"               ,   "hardcoded node ID", 16, 16},
  {"(PRINT|Print|print)\(['"+'"]'     ,   "print statement", 0, 32},
  {"//[ \t]*(TODO|ToDo|todo|2do)"    ,    "open TODO", 0, 32},
  {"(IF|if)[ \t]*\(0\)"               ,   "commented PQL code fragment", 0, 32},
  {"[\s]*(IF 1==0|IF 0==1|IF 0)[\s]*" ,   "commented DFA code fragment", 0, 32},
  // feel free to extend this table for your own needs, e.g. if you want to find forgotten Hugo's :-)
  {"HUGO|Hugo|hugo"                   ,   '"Hugo"', 16, 16} 
);
  
//====END_CONFIGURATION===========================================================================================================================










// ===- Initialization and preparation -===


// constants
@VERSION     = "v4.5";
@MSG_ERROR   = 'PFGM0001E';
@MSG_WARNING = 'PFGM0002W';
@MSG_INFO    = 'PFGM0003I';
@CR = char(10);
@CRLF = char(10)+char(13);
@TAB  = char(9);
@PERCENT = char(37);
@STAR = '*';
@OBJECT_TYPE_CLASSES   = 1;
@OBJECT_TYPE_TEMPLATES = 2;
@OBJECT_TYPE_INSTANCES = 3;
@OBJECT_TYPE_TABLE = array('classes', 'templates', 'instances');
@PQLPARAMPREFIX = 'PQLStatement=';
@EDITMODE_PQLSTATEMENT = 'PQL Statement';
@METHOD_PARAMS_PROPERTY_NAME = 'ParamDef';
@EXECUTION_MODE_DEFAULT       = 1;
@EXECUTION_MODE_METHOD_PARAMS = 2;
@FILE_EXTENSION_PQL = '.pql';
@FILE_EXTENSION_XML = '.xml';
@FILENAME_FORBIDDEN_CHARS = array('?','/','\','<','>',':','"','|','*',@PERCENT);
@DIR_SEPARATOR_WINDOWS = '\';
@DIR_SEPARATOR_UNIX    = '/';
@CSV_HEADER_LINE       = 'FILENAME;LINE;POSITION;MESSAGE_TYPE;CODE_CONTEXT';
@CSV_HEADER_SEARCHTEXT = 'SearchExpression: ';
@hexFormatString='@v.X@'; // for method IDs
@hexIdPrefix = "0x";
@exportFolderDFA = 'DFA';
@exportFolderPQL = 'PQL';
@exportFolderXML = 'XML';
@exportFileCodeCheck = 'code_checker.csv';
@codeCheckSeparator = ';';
@filenameOptionsSeparator = ';';
@filenameComponentSeparator = '_';
@dateTimeSeparator = '-';
@date = Substitute(ToString(date()),"/","")+"_"+Substitute(ToString(time()),":","");


// check if we are called from external - in that case override configuration variables with input parameters
// $param4 is always mandatory, so its a good candidate for checking this
@externalCall = false;
if ($param4 !=$invalid) then
  @externalCall = true;
endif 
  
if (@externalCall) then
  @exportDefinitionsPqlDefined       = ($param1 !=$invalid && Count($param1)>0 && $param1[1] != "");
  @exportDefinitionsResourcesDefined = ($param2 !=$invalid && Count($param2)>0 && $param2[1] != "");
  if ( @exportDefinitionsPqlDefined || @exportDefinitionsResourcesDefined ) then
    if (@exportDefinitionsPqlDefined)       then @exportDefinitionsPql       = $param1; endif
    if (@exportDefinitionsResourcesDefined) then @exportDefinitionsResources = $param2; endif
    @exportPathBase     = $param3;
    @exportTypes        = toInt($param4);
    @export_PQL = (@exportTypes & 1) >0; // lowest bit defines if PQL code is exported
    @export_DFA = (@exportTypes & 2) >0; // second lowest bit defines if DFA code is exported
    @export_XML = (@exportTypes & 4) >0; // third lowest bit defines if class definitions are exported in XML format
    if ($param5 !=$invalid) then 
      @flags    = $param5;
      @simulateExport              = (@flags &  1) > 0;  
      @performCodeCheck            = (@flags &  2) > 0;
      @generatePqlHeader           = (@flags &  4) > 0;
      @includeVersionChain         = (@flags &  8) > 0;
      @xmlComments                 = (@flags & 16) > 0;
      @xmlCreateCombinedOutputFile = (@flags & 32) > 0;
    endif
    if ($param6!=$invalid) then
      @userDefinedSearchExpression = $param6; 
      @searchExpressions  = Array({@userDefinedSearchExpression, "match", 32, 32});
      @csvLastColumnIndex = RPos(';', @CSV_HEADER_LINE);
      @csvLastColumnName  = Right(@CSV_HEADER_LINE, Length(@CSV_HEADER_LINE)- @csvLastColumnIndex);
      @csvLastColumnNameNew = '"' + @csvLastColumnName + ' ### '+@CSV_HEADER_SEARCHTEXT + Substitute(@userDefinedSearchExpression, '"', '""') + ' ###"';
      @CSV_HEADER_LINE = Substitute(@CSV_HEADER_LINE, @csvLastColumnName, @csvLastColumnNameNew);
    endif
    if ($param7!=$invalid) then 
      @filenameOptions   = split($param7,@filenameOptionsSeparator);
      @classPrefix             = @filenameOptions[1];
      @classAttributeSeparator = @filenameOptions[2];
      @classMethodSeparator    = @filenameOptions[3];
      @propertySeparator       = @filenameOptions[4];
      @propertyIndexSeparator  = @filenameOptions[5];
      @methodIdSeparator       = @filenameOptions[6];
      @templateNamingScheme    = @filenameOptions[7];
      @instanceNamingScheme    = @filenameOptions[8];
      @invalidCharReplacement  = @filenameOptions[9];
    endif
    if ($param8!=$invalid) then @verboseLevel      = toInt($param8);  endif
  else 
    message(@MSG_ERROR,'CodeExport '+@VERSION+': Not all mandatory input parameters have been provided');   
  endif
endif


// human readable description of attibute types
@attrTypeTable = Array('1','2','3','4','Integer','6','Float','String','9','Memory','Objref','12','Date/Time','14','Binary','Boolean','Binary remote',
                       '18','19','20','21','22','23','24','25','26','27','28','29','30','31','Date','Time','34','35','36','GUID','','AttrDefKey');

// human readable description of state transistion event types ($TransTargetState is zero based, so it has to be incremented by 1 to match with table)
@transEventTypeTable = Array('Call','Absolute time','Relative time','Change','Call tool','Call material','Program');


// prefixes in attribute properties that indicate PQL code
@propertyPrefixPQLTable      = Array('Pqlstatement=', 'PQL:');
@propertyPrefixPQLTableCount = count(@propertyPrefixPQLTable);

// List of method properties that may contain PQL code ($Param is not covered here as its treated separately)
// [Internal name   |   Visible Name     ]
@methodPropertyTable = Array(
{'$PreConstraints'  ,   'PreConstraints' },
{'$PostConstraints' ,   'Expression'     }
);

// List of attribute properties that may contain PQL code
// [Internal name   |   Visible Name      | Is Array | Only valid for $EditMode ]
@attributePropertyTable = Array(
{'$Constraints'     ,   'Constraints'     , 0, '*'},
{'$Range'           ,   'InputRange'      , 0, '*'},
{'$ViewConstraints' ,   'ViewConstraints' , 0, '*'},
{'$EditConstraints' ,   'EditConstraints' , 0, '*'},
{'$Substitutions'   ,   'Substitutions'   , 1, {'MultiListBox', 'ComboBox'}}
);

// Class feature table
// {  Name          ,   XML list tag name    ,   XML entry tag name     }  
@featureMappingTable = Array(
{'ClassDef'         ,   ''                   ,   'ClassDefinition'      },
{'AttrDef'          ,   'AttributeList'      ,   'AttributeDefinition'  },
{'MethDef'          ,   'MethodList'         ,   'MethodDefinition'     },
{'ParentDef'        ,   'ParentRefList'      ,   'ParentRefDefinition'  },
{'ChildDef'         ,   'ChildRefList'       ,   'ChildRefDefinition'   },
{'StateDef'         ,   'StateList'          ,   'StateDefinition'      },
//{'StateTransDef'    ,   'StateTransList'     ,   'StateTransDefinition' },
{'ParamDef'         ,   'ParamDef'           ,   'ParamDefEntry'        }  // has to be at the end 
);


// Property tables
// {Property Name, IsArray [0,1], OutputMode, BinVersion Required}
// OutputMode: 0=default (no special handling), 1=Base64, 2=LGUID, 3=AttrTypeName, 4=TransEventTypeName, 5=TransTargetStateName, 6=VisibleNameForOid]
@classMetadataTable = Array(
{'Id'                           ,0,0, 7.00}, // Object ID 
{'Name'                         ,0,1, 7.00}, // Visible Name
{'Internalname'                 ,0,0, 7.00}, // Internal name
{'Logicalguid'                  ,0,0, 7.00}, // Logical GUID
{'VersionGUID'                  ,0,0, 7.00}, // Version GUID
{'Constraints'                  ,0,0, 7.00}, // Constraints      
{'Created'                      ,0,0, 7.00}, // Creation Date
{'Modified'                     ,0,0, 7.00}, // Modify Date
{'Author'                       ,0,6, 7.00}, // Author
{'Inheritance'                  ,1,0, 7.00}, // Inheritance
{'Enginestatus'                 ,0,0, 7.00}, // Initial state
{'ObjectDescription'            ,0,1, 7.00}, // Object Description
{'Background'                   ,0,0, 7.00}, // Background color
{'Icon'                         ,0,2, 7.00}, // Icon reference
{'InstanceVersioning'           ,0,0, 7.14}, // Instance Versioning
{'Accessibility'                ,0,0, 7.14}, // Accessibility
{'Abstract'                     ,0,0, 7.14}, // Abstract
{'Final'                        ,0,0, 7.14}  // Final
);


@attributeMetadataTable = Array(
{'AttrId'                       ,0,0, 7.00}, // ID
{'AttrNameVisible'              ,0,1, 7.00}, // Name
{'AttrNameIntern'               ,0,0, 7.00}, // Internal (constraints) name
{'Type'                         ,0,3, 7.00}, // Type
{'DefaultValue'                 ,0,1, 7.00}, // Default
{'Substitutions'                ,1,1, 7.00}, // Substitution
{'Description'                  ,0,1, 7.00}, // Description
{'EditMode'                     ,0,0, 7.00}, // Edit
{'Constraints'                  ,0,1, 7.00}, // Constraints
{'Multiple'                     ,0,0, 7.00}, // Multiple value
{'ClassToReference'             ,0,0, 7.00}, // Class reference
{'SubstitutionsCount'           ,0,0, 7.00}, // Value count 
{'SortIndex'                    ,0,0, 7.00}, // Sort ID
{'TypeProperty'                 ,0,1, 7.00}, // Type property
{'EditProperty'                 ,0,1, 7.00}, // Edit property
{'VisibleForEdit'               ,0,0, 7.00}, // Visible for edit
{'Range'                        ,0,0, 7.00}, // Input range
{'Format'                       ,0,0, 7.00}, // Output format
{'ViewPrivileges'               ,1,0, 7.00}, // View Privilege
{'ViewConstraints'              ,0,1, 7.00}, // View Constraints
{'EditPrivileges'               ,1,0, 7.00}, // Edit Privilege    
{'EditConstraints'              ,0,1, 7.00}, // Edit Constraints
{'ProgTypeProperties'           ,0,0, 7.00}, // Program Type property
{'ContainsExpression'           ,0,0, 7.00}, // Contains Expression
{'TranslateContent'             ,0,0, 7.00}, // Translate Content
{'Docu'                         ,1,0, 7.00}, // Docu
{'CalculateDefaultValue'        ,0,0, 7.16}, // Calculate default
{'Accessibility'                ,0,0, 7.16}  // Accessibility
);


@methodMetadataTable = Array(
{'MethId'                       ,0,0, 7.00}, // Method ID
{'MethNameIntern'               ,0,0, 7.00}, // Method internal name
{'MethNameVisible'              ,0,1, 7.00}, // Method name
{'DontInherit'                  ,0,0, 7.00}, // Don't inherit to children
{'ValidForInstance'             ,0,0, 7.00}, // valid for Instance
{'ValidForTemplate'             ,0,0, 7.00}, // valid for Template
{'ValidForClass'                ,0,0, 7.00}, // valid for Clas   
{'ValidForState'                ,0,0, 7.00}, // Valid only for State machine
{'ValidForAgent'                ,0,0, 7.00}, // Valid for agent  
{'DefaultMethod'                ,0,0, 7.00}, // Default method
{'Type'                         ,0,0, 7.00}, // Method type
{'PreConstraints'               ,0,1, 7.00}, // Pre Constraints
{'PostConstraints'              ,0,1, 7.00}, // Expression
{'Privileges'                   ,1,0, 7.00}, // Privilege
{'VisibleInPopUp'               ,0,0, 7.00}, // Visible in PopUpMenu
{'VisibleInToolBox'             ,0,0, 7.00}, // Visible in Tool Box
{'LocalOnly'                    ,0,0, 7.00}, // Execute locally
{'ConnectToObject'              ,0,0, 7.00}, // Connect to object
{'ImplementedBy'                ,0,0, 7.00}, // Method implementation 
{'PrgName'                      ,0,0, 7.00}, // Par Exec
{'WrkDir'                       ,0,0, 7.00}, // Par Workd
{'LinePar'                      ,0,0, 7.00}, // Par Line
{'WindowMode'                   ,0,0, 7.00}, // Par Window
{'Description'                  ,0,1, 7.00}, // Description
{'ParamCount'                   ,0,0, 7.00}, // Parameter count
{'Param'                        ,1,1, 7.00}, // Parameter <x>
{'VersionContext'               ,0,0, 7.00}, // Version Context
{'ImplementationName'           ,0,0, 7.00}, // Method implementation name
{'Icon'                         ,0,0, 7.00}, // Icon
{'QuickLaunch'                  ,0,0, 7.00}, // Quick Launch  
{'Docu'                         ,1,0, 7.00}, // Docu
{'DisabledIfLockedForEdit'      ,0,0, 7.16}, // Disabled if locked for edit
{'ParamDef'                     ,0,0, 7.16}, // (memory buffer containing all parameter definitions)
{'EnvironmentVariables'         ,0,0, 7.16}, // Environment Variable [ImplementedBy=EYE|Shell]
{'ShellMode'                    ,0,0, 7.16}, // Shell Mode
{'ShellName'                    ,0,0, 7.16}, // Shell Name [ShellMode=2]
{'ParamHandling'                ,0,0, 7.16}, // Parameter Handling [ShellMode=2]
{'Accessibility'                ,0,0, 7.14}, // Accessibility
{'Abstract'                     ,0,0, 7.14}, // Abstract
{'Final'                        ,0,0, 7.14}, // Final
{'Delegate'                     ,0,0, 7.16}  // Delegate
);


@parentDefMetadataTable = Array(
{'RefId'                        ,0,0, 7.00}, // ID
{'RefNameVisible'               ,0,1, 7.00}, // Name
{'RefNameIntern'                ,0,0, 7.00}, // Internal (constraints) name
{'Description'                  ,0,0, 7.00}, // Description
{'Multiple'                     ,0,0, 7.00}, // Multiple value
{'VirtualReference'             ,0,0, 7.00}, // Virtual Reference
{'ClassToReference'             ,0,0, 7.00}, // Class reference
{'SortIndex'                    ,0,0, 7.00}, // Sort ID
{'PassVersionDate'              ,0,0, 7.00}, // Pass Version Date
{'SearchMethods'                ,0,0, 7.00}, // Search Methods
{'SearchAttributes'             ,0,0, 7.00}, // Serach Attributes
{'NewPrivileges'                ,1,0, 7.00}, // New Privilege
{'NewConstraints'               ,0,0, 7.16}, // New Constraints
{'DeletePrivileges'             ,1,0, 7.00}, // Delete Privilege
{'DeleteConstraints'            ,0,0, 7.16}, // Delete Constraints
{'MovePrivileges'               ,1,0, 7.00}, // Move Privilege
{'MoveConstraints'              ,0,0, 7.16}, // Move Constraints
{'Docu'                         ,1,0, 7.00}  // Docu
);


@childDefMetadataTable = Array(
{'RefId'                        ,0,0, 7.00}, // ID
{'RefNameVisible'               ,0,1, 7.00}, // Name
{'RefNameIntern'                ,0,0, 7.00}, // Internal (constraints) name
{'Description'                  ,0,0, 7.00}, // Description
{'Multiple'                     ,0,0, 7.00}, // Multiple value
{'ClassToReference'             ,0,0, 7.00}, // Class reference
{'SortIndex'                    ,0,0, 7.00}, // Sort ID
{'VersionContext'               ,0,0, 7.00}, // Version Context
{'PassVersionDate'              ,0,0, 7.00}, // Pass Version Date
{'SearchMethods'                ,0,0, 7.00}, // Search Methods
{'SearchAttributes'             ,0,0, 7.00}, // Serach Attributes
{'PassMoveObject'               ,0,0, 7.00}, // Pass Move Object
{'NewPrivileges'                ,1,0, 7.00}, // New Privilege
{'NewConstraints'               ,0,0, 7.16}, // New Constraints
{'DeletePrivileges'             ,1,0, 7.00}, // Delete Privilege
{'DeleteConstraints'            ,0,0, 7.16}, // Delete Constraints
{'MovePrivileges'               ,1,0, 7.00}, // Move Privilege
{'MoveConstraints'              ,0,0, 7.16}, // Move Constraints
{'SearchQuickLaunch'            ,0,0, 7.00}, // Search Quick Launch
{'Docu'                         ,1,0, 7.00}  // Docu
);


@stateTransDefMetadataTable = Array(
{'TransTargetState'             ,1,5, 7.00}, // Target state  
{'TransEventType'               ,1,4, 7.00}, // Event type
{'TransActivity'                ,1,1, 7.00}, // Action
{'TransConstraints'             ,1,1, 7.00}, // Guard
{'TransCallTriggerVisible'      ,1,1, 7.00}, // Call trigger
{'TransCallTriggerIntern'       ,1,1, 7.00}, // Internal call name
{'TransSendEvent'               ,1,0, 7.00}, // Send Event
{'TransTimeAbsolut'             ,1,0, 7.00}, // Time absolute
{'TransTimeRelativ'             ,1,0, 7.00}, // Time relative
{'TransChangeTrigger'           ,1,1, 7.00}, // Change trigger [TransEventType=Change]
{'TransStayConnected'           ,1,0, 7.00}, // Desktop stay connected
{'TransDocu'                    ,1,0, 7.00}, // Docu
{'TransDisabledIfLockedForEdit' ,0,0, 7.16}  // Disabled if locked for edit
);


@stateDefMetadataTable = Array(
{'StateId'                      ,0,0, 7.00}, // State ID
{'StateNameVisible'             ,0,1, 7.00}, // State name
{'Icon'                         ,0,0, 7.00}, // Icon
{'Background'                   ,0,0, 7.00}, // Background color
{'EntryActivities'              ,1,0, 7.00}, // Entry action
{'ExitActivities'               ,1,0, 7.00}, // Exit action
{'DoActivities'                 ,1,0, 7.00}, // Do activity
{'Attributes'                   ,1,0, 7.00}, // Valid attributes
{'ReceiveConstraints'           ,0,1, 7.00}, // Handle events if
{'SendConstraints'              ,0,1, 7.00}, // Send modification events if
{'EntryEvent'                   ,0,0, 7.00}, // Entry event
{'ExitEvent'                    ,0,0, 7.00}, // Exit event
{'DoEvent'                      ,0,0, 7.00}, // Do event
{'Docu'                         ,1,0, 7.00}  // Docu
);
ForEach @elem in (@stateTransDefMetadataTable)
  @stateDefMetadataTable = InsertValue(@stateDefMetadataTable, @elem); // AppendArray not available in v702
Next


@paramDefMetadataTable = Array(
{'InternalName'                 ,0,1, 7.16}, // Name
{'Type'                         ,0,0, 7.16}, // Type
{'Multiple'                     ,0,0, 7.16}, // Multiple value
{'Default'                      ,1,1, 7.16}, // Default [Optional=true]
{'Optional'                     ,0,0, 7.16}, // Optional
{'Description'                  ,0,1, 7.16}, // Description
{'DelegationAnchor'             ,0,0, 7.16}  // Delegation Anchor
);


// variable declarations
@self = $self.$id,$node;
@node = @self.$node;
@objCountDFA = 0;
@objCountPQL = 0;
@objCountXML = 0;
@fileHeader= '';
@codeExportTable      = Array();
@codeExportTableEntry = Array(); // [filename] [file content | 'DFACODE'] [file header | <RESOURCE_OID>]
@nonUniqueCLasses     = Array();
@codeCheckMessageTable = @CSV_HEADER_LINE+@CR;
@codeCheckMessageCount = 0;
@xml_author                = $CurrentUserId.$name;
@xml_date                  = DateTime(); 
@xml_commentPrefix         = '<!-- ';
@xml_commentSuffix         = ' -->';
@xml_minusminusReplacement = "#minus-minus#"; // XML-comments must not contain "--"
@xml_base64charsPerLine    = 64;
@xmlCombinedOutputFilename = "_ClassExport_" + @date + ".xml";
@xmlDataCombined           = '';

// determine directory separator of current OS platform
@nodeInformation = @node\(NodeInformation:).$id,*;
@env = fromMem(@nodeInformation.Environment);
@osPath = @env\$subset(*:.Name=='ISIS_OBJECT_SPACE').Value;
if (left(@osPath, 1)==@DIR_SEPARATOR_UNIX) then
  @dirSeparator = @DIR_SEPARATOR_UNIX;
else
  @dirSeparator = @DIR_SEPARATOR_WINDOWS;
endif  

if (right(@exportPathBase,1) != @dirSeparator) then
  @exportPathBase+=@dirSeparator;
endif
@exportPath = @exportPathBase + @date+@dirSeparator; 


// end script in case there is nothing to do
if (!@export_DFA && !@export_PQL && !@export_XML) then
  if (@verboseLevel > 0) then
    message(@MSG_INFO,'CodeExport '+@VERSION+': Nothing to do. Please activate one or more export options for DFA, PQL and XML.');
  endif
  return 0;
endif;


// determine whether function "BinaryExportExtended" is supported (if not, output folders are created via temporary batch file)
@classData        = {8a84cf10-0b7a-389b-836f-4ba000365dcd};
@classRcResource  = {86e9223c-57ac-304a-b75a-09f39618a40e};
@exportMethodData       = @classData      \$MethDef(.$ImplementationName like "BinaryExportExtended").$MethNameIntern;
@exportMethodRcResource = @classRcResource\$MethDef(.$ImplementationName like "BinaryExportExtended").$MethNameIntern;
@binVersion = ParseAmount(Left($CurrentNodeId.BuildNumber,4));


// use build-in method BinaryExportExtended if supported by both frameworks and binaries
if (IsInvalid(@exportMethodData) OR IsInvalid(@exportMethodRcResource) OR @binVersion < 7.12) then
  @isBinExpExtSupported = false;
else
  @isBinExpExtSupported = true;
endif


// create helper objects needed for file export
if (@simulateExport==false) then
    
  // create temporary data object to export code to filesystem
  @dataGenericBinaryClass  = \{e1d3371a-1068-11d8-ab33-7bec1e1d933d}.$Id,$LogicalGUID;
  @exportTool = @node.call("InstantiateTransient",@DataGenericBinaryClass.$LogicalGUID);
  @exportTool = @exportTool.Return1;
  @exportToolBinAttrName = 'TargetName';

  if (!@isBinExpExtSupported) then
    // prepare batch file to create folder structure in @exportPathBase
    @cmdFileName    = 'codeexport.bat';
    @cmd_folderDFA = "";
    @cmd_folderPQL = "";
    @cmd_folderXML = "";
    if (@export_DFA) then @cmd_folderDFA = 'mkdir %1\'+@exportFolderDFA+@CRLF; endif;
    if (@export_PQL) then @cmd_folderPQL = 'mkdir %1\'+@exportFolderPQL+@CRLF; endif;
    if (@export_XML) then @cmd_folderXML = 'mkdir %1\'+@exportFolderXML+@CRLF; endif;
    @cmdFileContent = '@echo off'+@CRLF+'mkdir %1'+@CRLF+ @cmd_folderDFA + @cmd_folderPQL + @cmd_folderXML + @CRLF +'del %0' + @CRLF;

    // create temporary externalApplication object to execute a shell script that creates output folders 
    $local,$0: @externalApplicationClass = $search($classes of ExternalApplication:).$id,$LogicalGUID top 1;
    @extAppTool = @node.call("InstantiateTransient",@ExternalApplicationClass.$LogicalGUID);
    @extAppTool = @extAppTool.Return1;

    @extAppTool.Command = @exportPathBase + @cmdFileName;
    @extAppTool.WorkDir = @exportPathBase;
    @extAppTool.ToolParameters = @date;

    @fileHandle = FileOpen(@exportTool.$id,@exportToolBinAttrName,'w');
    @fileHandle.$FileWrite(@cmdFileContent);
    @fileHandle.$FileClose();
    $local($ie):@rc = @exportTool.call("BinaryExport",@exportToolBinAttrName,@exportPathBase+@cmdFileName);

    if (@rc != 0) then
      message(@MSG_ERROR,' Binary export failed for file '+@exportPathBase+@cmdFileName);  
    endif

    $local($ie):@rc = @extAppTool.LaunchOnce(); // RC is 0 even though warnings like "Object xxx not found" are shown

    if (@rc != 0) then
      message(@MSG_INFO,' Script "'+ @cmdFileName +'" ended with RC='+@rc);  
    endif
  endif
endif // (@simulateExport==false)


// header message
if (@verboseLevel > 0) then
  message(@MSG_INFO, '');
  message(@MSG_INFO, '=== CodeExport '+@VERSION+' =============================================================================');
  message(@MSG_INFO, '');
endif

// output call parameters
if (@verboseLevel >= 5 && @externalCall) then
  message(@MSG_INFO, ' Script was called from external with following parameters:');
  @idx = 1;
  // first two parameters are arrays and require some special handling for nice output..  
  while (@idx <= 2) 
    @paramString = "[";
    select (@idx)
      case 1: @paramIdx = $param1; break;
      case 2: @paramIdx = $param2; break;
    endselect
    if (count(@paramIdx)==0) then
      @paramString = "[]";
    else
      forEach @s in (@paramIdx)
        @paramString+='"'+@s+'",';
      next
      @paramString = subStr(@paramString, 1, length(@paramString)-1) + ']';
    endif
    message(@MSG_INFO, ' -> $param'+@idx+'  = '  + @paramString);
    @idx++;
  next
  message(@MSG_INFO, ' -> $param3  = '  + $param3);
  message(@MSG_INFO, ' -> $param4  = '  + $param4);
  message(@MSG_INFO, ' -> $param5  = '  + $param5);
  message(@MSG_INFO, ' -> $param6  = '  + $param6);
  message(@MSG_INFO, ' -> $param7  = '  + $param7);
  message(@MSG_INFO, ' -> $param8  = '  + $param8);
endif
if (@verboseLevel > 3) then
  if(@isBinExpExtSupported) then
    message(@MSG_INFO, ' "BinaryExportExtended" feature is supported');
  endif
endif 

//===- Extract DFA code from resources -===

if (@export_DFA) then
  // create set of resources to export
  @resourceSetToExport = CreateSet({});
  if (@includeVersionChain) then
    $0($im): @resourceSetToExport = $search($instances of DFA,INC:(.$name like @exportDefinitionsResources)).$id,$name,$created,Content,Type;
  else
    $0($v,$im): @resourceSetToExport = $search($instances of DFA,INC:(.$name like @exportDefinitionsResources)).$id,$name,$created,Content,Type;
  endif

  forEach @resource in (@resourceSetToExport)
    if (toString(@resource.Content) like '$$Binary$$*') then
      // add entry to codeExportTable
      @fileNameAppendix = '';
      if (@includeVersionChain) then
        @creationDate = ToString(@resource.$Created);
        @creationDate = Substitute(@creationDate,":","");
        @creationDate = Substitute(@creationDate,"/","");
        @creationDate = Substitute(@creationDate," ","-");
        @creationDate = Left(@creationDate, Length(@creationDate)-2);
        @fileNameAppendix = @methodIdSeparator + @creationDate + @methodIdSeparator + @resource.$id;
      endif
      @fileName = @resource.$name + @fileNameAppendix+ "." + @resource.Type;
      @codeExportTableEntry = {'DFA', @fileName,'DFACODE',@resource.$id};
      @codeExportTable = insertValue(@codeExportTable,@codeExportTableEntry);
    endif
  next
endif // (@export_DFA)



//===- Generate list of relevant objects for PQL code export -===

if (@export_PQL OR @export_XML) then

  // create set of classes to export
  @classSetToExport    = createSet({});
  @templateSetToExport = createSet({});
  @instanceSetToExport = createSet({});

  forEach @entry in (@exportDefinitionsPql)

    if (Trim(@entry)=="") then next; endif // ignore empty lines
    @ignoreEntry = false;
    
    // determine type of objects defined by current entry
    // type prefix is optional for classes and templates (C: and T:) but required for instances (I:)
    @entryDefinesInstances = (left(@entry,3)=='I:<' && pos('>',@entry)>0);
    if (@entryDefinesInstances) then
      @objType = @OBJECT_TYPE_INSTANCES;
    else
      @entryDefinesTemplates = ((left(@entry,1)=='<' || left(@entry,3)=='T:<') && (pos('>',@entry)>0)); 
      if (@entryDefinesTemplates) then
        @objType = @OBJECT_TYPE_TEMPLATES; 
      else
        // for classes, the object type definition is not needed
        @objType = @OBJECT_TYPE_CLASSES;
      endif
    endif  

    if (@entryDefinesInstances OR @entryDefinesTemplates) then
      @pos1 = pos('<',@entry);
      @pos2 = pos('>',@entry);
      @objClass = subStr(@entry, @pos1+1, @pos2-@pos1-1);
      @objName  = subStr(@entry, @pos2+1);
      if (@objClass=="") then
        @ignoreEntry=true;
      endif  
      if (@objName=="") then 
        @objName='*'; 
      endif
    else
      @objClass = '*';
      @objName = @entry;
      if (left(@entry,2)=='C:') then
        @objName = right(@entry, length(@entry)-2);
      endif
      if (@objName=="") then 
        @ignoreEntry=true; 
      endif
    endif

    if (@ignoreEntry) then
      message(@MSG_WARNING, ' Entry "'+@entry+'" in "Export Definitions Pql" is not correct and will be ignored. Please check the syntax.');
    else
      if (@verboseLevel > 1) then
        message(@MSG_INFO, ' Searching for '+@OBJECT_TYPE_TABLE[@objType]+' of type '+@objClass+' with name like "'+@objName+'"...');
      endif  
      select(@objType)
        case 1:

          @propertyList = Array();
          ForEach @entry in (@classMetadataTable)
            @requiredBinVersion = @entry[4];
            if (@binVersion >= @requiredBinVersion) then
            @propertyList = InsertValue(@propertyList, '$'+@entry[1]);
            endif
          Next

          if (@includeVersionChain) then
            $0($im):    @set = $search($classes of *:.$internalname like @objName).@propertyList;
          else
            $0($v,$im): @set = $search($classes of *:.$internalname like @objName).@propertyList;
          endif  
          @classSetToExport = union(@set, @classSetToExport);
          break;
        case 2:
          if (@includeVersionChain) then
            $0($im):    @set = $search($templates of @objClass:.$name like @objName).$id,$internalname,$displayname,$created,$Modified,$Author,$Inheritance,$Logicalguid,$VersionGUID,$Enginestatus,$ObjectDescription,$Background,$Icon,$ObjType,*;
          else
            $0($v,$im): @set = $search($templates of @objClass:.$name like @objName).$id,$internalname,$displayname,$created,$Modified,$Author,$Inheritance,$Logicalguid,$VersionGUID,$Enginestatus,$ObjectDescription,$Background,$Icon,$ObjType,*;
          endif
          @templateSetToExport = union(@set, @templateSetToExport);
          break;
        case 3:
          if (@includeVersionChain) then
            $0($im):    @set = $search($instances of @objClass:.$name like @objName).$id,$internalname,$displayname,$created,$Modified,$Author,$Inheritance,$Logicalguid,$VersionGUID,$ObjectDescription,$Background,$Icon,$ObjType,*;
          else
            $0($v,$im): @set = $search($instances of @objClass:.$name like @objName).$id,$internalname,$displayname,$created,$Modified,$Author,$Inheritance,$Logicalguid,$VersionGUID,$ObjectDescription,$Background,$Icon,$ObjType,*;
          endif
          @instanceSetToExport = union(@set, @instanceSetToExport);
          break;
      endselect
      if (@verboseLevel > 1) then
        message(@MSG_INFO, '  -> Found '+count(@set)+' '+@OBJECT_TYPE_TABLE[@objType]+' to export');
      endif  
    endif
  next
  @classCount    = count(@classSetToExport);
  @templateCount = count(@templateSetToExport);
  @instanceCount = count(@instanceSetToExport);
endif // (@export_PQL OR @export_XML)



//===- Start code extraction ===-

@classIdx = 1;
@treeLevel = 1;
forEach @class in (@classSetToExport)
  
    @className = @class.$internalname;
    @classDuplicateCount = count(@classSetToExport\$Subset(*:.$InternalName==@className).$LogicalGUID groupby $LogicalGUID);
    @isDuplicateClass = (!@includeVersionChain) && (@classDuplicateCount>1);
    if (@isDuplicateClass AND !inArray(@nonUniqueCLasses, @className)) then
      @nonUniqueCLasses = InsertValue(@nonUniqueCLasses, @className);
      if (@verboseLevel>3) then
        message(@MSG_WARNING, ' -> Found '+@classDuplicateCount+' duplicates for class "'+@className+'".');
      endif
    endif
    @fileNameAppendix = '';
    if (@includeVersionChain) then
      @creationDate = ToString(@class.$Created);
      @creationDate = Substitute(@creationDate,":","");
      @creationDate = Substitute(@creationDate,"/","");
      @creationDate = Substitute(@creationDate," ","-");
      @creationDate = Left(@creationDate, Length(@creationDate)-2);
      @fileNameAppendix = @methodIdSeparator + @creationDate + @methodIdSeparator + @class.$id;
    endif


//===- Extract PQL code from attribute properties -===

  if (@export_PQL) then
    if (@verboseLevel>2) then
      message(@MSG_INFO, ' -> Extracting PQL code from class "'+@className+'" ['+@class.$id+']  ('+@classIdx+' of '+@classCount+')');
    endif
    @attributeDefinitionSet = @class\$AttrDef.$AttrId,$AttrNameVisible,$AttrNameIntern,$Constraints,$Range,$ViewConstraints,$EditConstraints,$EditMode,$Substitutions;
    forEach @attribute in (@attributeDefinitionSet)
      @attributeName = @attribute.$AttrNameIntern;
      forEach @entry in (@attributePropertyTable)
        @attrPropertyNameIntern  = @entry[1];
        @attrPropertyNameVisible = @entry[2];
        @attrPropertyIsArray     = @entry[3];
        @attrPropertyEditMode    = @entry[4];
        @property  = @attribute.@attrPropertyNameIntern;
        @propertyCount = count(@property);  
     
        if (@attribute.$EditMode like @attrPropertyEditMode) then
          // loop through attribute property values (e.g. $substitutions can contain several values)
          @propertyIdx = 1;
          while (@propertyIdx <= @propertyCount)
          @content = @property[@propertyIdx];     
            if (left(@content,4) like 'PQL:') then
            @content = right(@content,length(@content)-4);
            @propertyIdxName = '';
            if (@attrPropertyIsArray) then
              @propertyIdxName = @propertyIndexSeparator + @propertyIdx;
            endif
            @fileName = @classPrefix + @className + @classAttributeSeparator + @attributeName + @propertySeparator + 
              @attrPropertyNameVisible + @propertyIdxName + @fileNameAppendix + @FILE_EXTENSION_PQL;
            @codeExportTableEntry = {'PQL', @fileName,@content,""}; 
            @codeExportTable = insertValue(@codeExportTable,@codeExportTableEntry);
            endif;
            @propertyIdx++;
          next     
        endif
      next
    next


//===- Extract PQL code from method definitions -===

    @methodDefinitionSet = @class\$MethDef.$MethId,$MethNameVisible,$MethNameIntern,$PreConstraints,$PostConstraints,$ImplementationName,$Description,$Type,$Param,$Paramcount;
    
    forEach @method in (@methodDefinitionSet)
      @methodName = @method.$MethNameIntern;
      @methodId = @method.$MethId;
      @methodImplName = @method.$ImplementationName;
      // append method ID as suffix to filename if there are multiple methods with same internal name
      @isMethodNameUnique = (Count(@methodDefinitionSet\$Subset(.$MethNameIntern==@methodName))<=1);
      @methodNameSuffix = "";
      if (!@isMethodNameUnique) then
        @methodNameSuffix = @methodIdSeparator + @hexIdPrefix + format(@hexFormatString,@methodId);
      endif

      // process method properties     
      forEach @entry in (@methodPropertyTable)
        @methodPropertyNameIntern  = @entry[1];
        @methodPropertyNameVisible = @entry[2];
        @content = @method.@methodPropertyNameIntern;
        if (Left(@content,4) like 'PQL:') then
          @content = Right(@content,Length(@content)-4);          
          @fileName = @classPrefix + @className + @classMethodSeparator + @methodName + @propertySeparator + 
            @methodPropertyNameVisible + @methodNameSuffix + @fileNameAppendix + @FILE_EXTENSION_PQL;
          @codeExportTableEntry = {'PQL', @fileName,@content,""}; 
          @codeExportTable = InsertValue(@codeExportTable,@codeExportTableEntry);
        endif;
      next
      
      // process PqlExecute methods
      @isPqlExecuteMethod = (@methodImplName like 'PqlExecute*' AND @method.$Paramcount>0); // PqlExecute methods need at least one parameter
      if (!@isPqlExecuteMethod) then
        next; // jump to next method
      endif
      
      // loop through method params (last param that starts with "PQLStatement=" is executed by system)
      @idxParam = 1;
      @pqlStatement = "";
      @pqlParamHeaderInfo = "";
      while (@idxParam <= count(@method.$Param))
        @currentParam = @method.$Param[@idxParam];
        if (Left(@currentParam,length(@PQLPARAMPREFIX)) like @PQLPARAMPREFIX) then
          @pqlStatement = @currentParam;
        else
          // all params that do not contain PQL code are printed in header information
          @pqlParamHeaderInfo += ' *      Param'+@idxParam+': '+@method.$Param[@idxParam]+@CR; 
        endif
        @idxParam++;
      next
      @pqlParamHeaderInfo = left(@pqlParamHeaderInfo, Length(@pqlParamHeaderInfo)-1);

      if (@pqlStatement=="") then
        message(@MSG_WARNING,'PqlExecute method "'+@methodName+'" of class '+@className+' has no PQLStatement defined.');
      else 
        @pqlStatement = Substitute(@pqlStatement, "PQLStatement=", "");
        //@pqlStatement = Substitute(@pqlStatement, 2*@PERCENT+"=", 5*@PERCENT+"="); // workaround for binariy versions <7.1 due to bug with percent signs  
        @pqlStatement = Substitute(@pqlStatement, 2*@PERCENT, @PERCENT);
        @pqlStatement = Substitute(@pqlStatement, @PERCENT+"=", "=");

        @fileHeader = '';
        if (@generatePqlHeader) then
         // generate header information
          @fileHeader += '/'+@STAR+@STAR+@CR;
          @fileHeader += ' *   CodeExport '+@VERSION+@CR;
          @fileHeader += ' *   2010-2013 by TimoP'+@CR;
          @fileHeader += ' *   File generated at '+DateTime()+' by '+$CurrentUserId.$name+''+@CR; 
          @fileHeader += ' *   ---'+@CR;
          @fileHeader += ' *   Visible Name:    '+@method.$MethNameVisible+@CR;
          @fileHeader += ' *   Internal Name:   '+@method.$MethNameIntern+@CR;
          @fileHeader += ' *   Description:     '+@method.$Description+@CR;

          ForEach @methodProperty in (@methodPropertyTable)
            @content = @method.@methodProperty[1];
            @content = Substitute(@content,@STAR+'/','* /'); 
            if (Left(@content,4) like 'PQL:') then
              @content = Right(@content,Length(@content)-4);
              @content = Substitute(@content, @CR, @CR+' *      ');  
              @content = @CR+' *      '+@content;            
            endif;
            @fileHeader += ' *   '+@methodProperty[2]+':  '+@content+@CR;
          Next

          @fileHeader += ' *   Parameter:     '+@CR;
          if (@pqlParamHeaderInfo!="") then
            @fileHeader += @pqlParamHeaderInfo+@CR;
          endif
          @fileHeader += ' *'+@CR;
          @fileHeader += @STAR+@STAR+'/'+@CR+@CR;
        endif // (@generatePqlHeader)

        // add entry to codeExportTable
        @fileName = @classPrefix + @className + @classMethodSeparator + @methodName + 
          @methodNameSuffix + @fileNameAppendix + @FILE_EXTENSION_PQL;
        @codeExportTableEntry = {'PQL', @fileName,@pqlStatement,@fileHeader};
        @codeExportTable = InsertValue(@codeExportTable,@codeExportTableEntry);
      endif // @pqlStatement==""
      
      @fileHeader = '';
    next // @method in (@methodDefinitionSet)
  endif // (@export_PQL)


//===- Generate XML files from class definitions -===

  if (@export_XML) then

    // create XML header
    @xml_author  = $CurrentUserId.$name;
    @xml_date    = DateTime();
    @xml_HEADER = "";
    @xml_HEADER += '<?xml version="1.0" encoding="UTF-8" standalone="no" ?>'+@CR;
    @xml_HEADER += '<envelope>'+@CR;
    @xml_HEADER += @TAB+'<metadata>'+@CR;
    @xml_HEADER += 2*@TAB+'<version>';
    @xml_HEADER += @VERSION;
    @xml_HEADER += '</version>'+@CR;
    @xml_HEADER += 2*@TAB+'<author>';
    @xml_HEADER += @xml_author;
    @xml_HEADER += '</author>'+@CR;
    @xml_HEADER += 2*@TAB+'<date>';
    @xml_HEADER += @xml_date;
    @xml_HEADER += '</date>'+@CR;
    @xml_HEADER += @TAB+'</metadata>'+@CR;
    @xml_HEADER += @TAB+"<classList>"+@CR;

    // create XML trailer
    @xml_TRAILER = "";
    @xml_TRAILER += @TAB+"</classList>"+@CR;
    @xml_TRAILER += '</envelope>';

    if (@verboseLevel>2) then
      message(@MSG_INFO, ' -> Creating XML output for class "'+@className+'" ['+@class.$id+']  ('+@classIdx+' of '+@classCount+')');
    endif

    // create XML output for current class definition
    @classTreelevel = count (@class.$Inheritance)-2;
    @parentClassInternalName = @class\$AllParents($classes of *:).$InternalName top 1;

    @xmlData = '';
    @xmlData += @treelevel*@TAB+'<class ParentClass="'+@parentClassInternalName+'" TreeLevel="'+@classTreelevel+'">'+@CR;

    @executionMode            = @EXECUTION_MODE_DEFAULT;
    @currentMethodId          = $invalid;
    @idxLastProcessedFeature  = $invalid;
    @idxLastProcessedEntity   = $invalid;
    @idxLastProcessedProperty = $invalid;

    @idxFeature = 1;
    @abortLoop = false;

    while (@idxFeature<Count(@featureMappingTable)) // LOOP 1: class features (method list, attribute list, ...)

      if (@executionMode==@EXECUTION_MODE_METHOD_PARAMS) then
        @idxFeature = Count(@featureMappingTable); // ParamDef has to be last entry in table!
        @abortLoop = false;
      endif

      //message(@MSG_INFO, 'LOOP 1 >> feature '+@idxFeature+': '+@featureMappingTable[@idxFeature][1]);

      @classFeature                 = @featureMappingTable[@idxFeature][1];
      @classFeatureXmlParentTagName = @featureMappingTable[@idxFeature][2];
      @classFeatureXmlEntryTagName  = @featureMappingTable[@idxFeature][3];

      Select (@classFeature)
        Case 'ClassDef':
          @featurePropertyTable = @classMetadataTable;
          break;
        Case 'AttrDef':
          @featurePropertyTable = @attributeMetadataTable;
          break;
        Case 'MethDef':
          @featurePropertyTable = @methodMetadataTable;
          break;
        Case 'ParentDef':
          @featurePropertyTable = @parentDefMetadataTable;
          break;
        Case 'ChildDef':
          @featurePropertyTable = @childDefMetadataTable;
          break;
        Case 'StateDef':
          @featurePropertyTable = @stateDefMetadataTable;
          break;
        Case 'ParamDef':
          @featurePropertyTable = @paramDefMetadataTable;
      EndSelect

      @propertyList = Array();
      
      ForEach @entry in (@featurePropertyTable)
        @requiredBinVersion = @entry[4];
        if (@binVersion >= @requiredBinVersion) then
          @propertyList = InsertValue(@propertyList, '$'+@entry[1]);
        endif
      Next

      Select (@classFeature)
        Case 'ClassDef':
          @featureProperties  = @class.@propertyList;
          break;
        Case 'AttrDef': 
          @featureProperties  = @class\$AttrDef.@propertyList;
          break;
        Case 'MethDef':
          @featureProperties  = @class\$MethDef.@propertyList; 
          break;
        Case 'ParentDef':
          @featureProperties  = @class\$ParentDef.@propertyList; 
          break;
        Case 'ChildDef':
          @featureProperties  = @class\$ChildDef.@propertyList; 
          break;
        Case 'StateDef':
          @featureProperties  = @class\$StateDef.@propertyList;
          break;
        Case 'ParamDef':
          @featureProperties  = fromMem(@class\$MethDef(.$MethId==@currentMethodId).$ParamDef);
          // add column for 'DelegationAnchor' in case its missing
          @isParamDefIncomplete = Count(@featureProperties\$subset(.DelegationAnchor!=$invalid).InternalName)==0;
          if (@isParamDefIncomplete) then
            @featureProperties = @featureProperties\$subset.($invalid) as "DelegationAnchor",*;
          endif
      EndSelect
      @featurePropertiesCount = Count(@featureProperties);

      // restore index after method paramdef processing has finished
      if (@idxLastProcessedEntity && @executionMode == @EXECUTION_MODE_DEFAULT) then
        @idxEntity = @idxLastProcessedEntity;
        @idxLastProcessedEntity = $invalid;
      else
        @idxEntity = 1; 
        @treeLevel++;
        if (@classFeatureXmlParentTagName != "") then
          @xmlData += @treelevel*@TAB+"<"+@classFeatureXmlParentTagName+">"+@CR;
          @treeLevel++;
        endif    
      endif

      While (@idxEntity<=@featurePropertiesCount) // LOOP 2: single attribute, method, ...
 
        @attribute = @featureProperties[@idxEntity];
        if (@classFeature=='MethDef') then
          @currentMethodId = @attribute.$MethId;
        else
          @currentMethodId = $invalid;
        endif

        //message(@MSG_INFO, 'LOOP 2 >> entity (row) '+@idxEntity + ' --- '+format(@hexFormatString,@currentMethodId));

        // restore index after method paramdef processing has finished
        if (@idxLastProcessedProperty && @executionMode == @EXECUTION_MODE_DEFAULT) then
          @idxFeatureValues = ++@idxLastProcessedProperty; // jump to next property as ParamDef has been handled
          @idxLastProcessedProperty = $invalid;
        else
          @idxFeatureValues = 1;  
          @xmlData += @treelevel*@TAB+"<"+@classFeatureXmlEntryTagName+">"+ @CR;       
        endif   
        @treeLevel++;

        While (@idxFeatureValues <= (count(@featurePropertyTable))) // LOOP 3: properties
 
          //message(@MSG_INFO, 'LOOP 3 >> property '+@idxFeatureValues+': '+@featurePropertyTable[@idxFeatureValues][1]);

          @property = @featurePropertyTable[@idxFeatureValues][1];
          // for method params processing, exit loop and store current index to return later
          if (@property==@METHOD_PARAMS_PROPERTY_NAME AND @classFeature=='MethDef') then
            @idxLastProcessedProperty = @idxFeatureValues;
            @executionMode = @EXECUTION_MODE_METHOD_PARAMS;
            @abortLoop = true;
            break; // go back to method loop (as $ParamDef is only defined in the context of a method)
          endif

          @propertyIsArray = @featurePropertyTable[@idxFeatureValues][2];       
          @propertyEncode  = @featurePropertyTable[@idxFeatureValues][3];
          @propertyPrefix = '$';
          if (@executionMode==@EXECUTION_MODE_METHOD_PARAMS) then
            @propertyPrefix = '';
          endif
          @propertyDollar  = @propertyPrefix+@property;
          @propertyValue   = @attribute.@propertyDollar;

          if (InArray({'AttrId','MethId','RefId','SortIndex'}, @property)) then
            @propertyValue = @hexIdPrefix + format(@hexFormatString,@propertyValue);
          endif          
          @attrPropertyEntryCount = count(@propertyValue);

          // quick exit for empty scalar values
          if (!@propertyIsArray AND (@attrPropertyEntryCount==0 OR ToString(@propertyValue)=='')) then
            @xmlData += @treelevel*@TAB+'<'+@property+'></'+@property+'>'+@CR;
            @idxFeatureValues++;
            next;
          endif

          // ignore strange entries like "/@$!#0076f#ID" in privilege array
          if (@property like '*Privileges') then
            if (@attrPropertyEntryCount>0 && left(@propertyValue[@attrPropertyEntryCount],2)!='$_') then
              @attrPropertyEntryCount--;
            endif
          endif

          @arrayIndex = 1;
          @arrayXmlTagPropertyString = '';

          While (@arrayIndex <= @attrPropertyEntryCount)
            @propertyValueOrig = tostring(@propertyValue[@arrayIndex]);
            @propertyValueNew = @propertyValueOrig;
            @len_AttrPropertyValue = length(@propertyValueOrig);
                           
            if (@propertyIsArray) then
               @arrayXmlTagPropertyString = ' idx="'+@arrayIndex+'"';
            endif


            // quick exit for empty values
            if (ToString(@propertyValueOrig)=='' OR @propertyValueOrig==$invalid) then
              @xmlData += @treelevel*@TAB+'<'+@property+@arrayXmlTagPropertyString+'></'+@property+'>'+@CR;
              @arrayIndex++;
              next;
            endif


            // check if attribute property value has to be encoded or otherwise tranformed
            if (@propertyEncode==1) then
               @propertyValueNew=Base64Encode(@propertyValueNew,@xml_base64charsPerLine);
              @propertyValueNew=Left(@propertyValueNew, Length(@propertyValueNew)-1);
            elseif (@propertyEncode==2) then
              @objref=@propertyValueNew;
              @propertyValueNew=@objref.$logicalguid;
            endif
            
            // check if we want a XML comment for this attribute property
            @generateXmlComment = (@xmlComments AND @propertyEncode);// AND (@propertyValueNew!=''));
            @multiLine = (length(@propertyValueNew) > @xml_base64charsPerLine) OR @generateXmlComment;      
            if (@generateXmlComment) then
              @propertyValueComment = @propertyValueOrig;
              Select (@propertyEncode)
                Case 0: break;
                Case 3: 
                  @propertyValueComment = @attrTypeTable[Toint(@propertyValueOrig)];
                  break;
                Case 4:
                  @propertyValueComment = @transEventTypeTable[Toint(@propertyValueOrig)+1];
                  break;
                Case 5:
                  @propertyValueComment = @class\$StateDef(.$StateId==Toint(@propertyValueOrig)).$StateNameVisible;
                  break;
                Case 6:
                  if (IsObjRef(@propertyValue) AND @propertyValue!=0.0.0.ffff) then
                    @propertyValueComment = @attribute\@propertyDollar.$name;
                  endif
                  break;
              EndSelect
              
              // special handling for XML comments containing PQL code
              @idx_PropertyPrefixPQLTable = 1;
              @propertyContainsPQL = 0;
              While (@idx_PropertyPrefixPQLTable <= @propertyPrefixPQLTableCount)
                @propertyPrefixPQL = @propertyPrefixPQLTable[@idx_PropertyPrefixPQLTable];
                @idx_PropertyPrefixPQLTable++;
                @len_PropertyPrefixPQL = length(@propertyPrefixPQL);        
                if (Left(@propertyValueOrig, @len_PropertyPrefixPQL) like @propertyPrefixPQL) then
                   @propertyContainsPQL = 1;
                   @propertyValueComment = Right(@propertyValueOrig, (@len_AttrPropertyValue - @len_PropertyPrefixPQL));
                   @propertyValueComment = Substitute(@propertyValueComment, @PERCENT+'=', '=');
                   break;
                endif
              Next 

              // replace all "--" strings in comment as it would be treated as the end of the XML comment
              @xmlSpacePqlProperty = '';
              if (@propertyContainsPQL) then
                @xmlSpacePqlProperty = @CR;
              endif

              @propertyValueComment = @xml_commentPrefix+@xmlSpacePqlProperty+substitute(@propertyValueComment,"--",@xml_minusminusReplacement)+@xmlSpacePqlProperty+@xml_commentSuffix; 
            else
              @propertyValueComment = '';
            endif               
            
            @xmlTagLineEnd = '';
            @xmlTagLineEndComment ='';
            @newIndent = '';
            @xmlSpaceTagClose = '';          
            if (@multiLine) then
              @xmlTagLineEnd = @CR;
              @newIndent = (@treelevel+1)*@TAB;
              @xmlTagLineEndComment = @CR;
              @xmlSpaceTagClose = @CR + @treelevel*@TAB;
            endif

            @line = @treelevel*@TAB+
                    '<'+@property+@arrayXmlTagPropertyString+'>'+@xmlTagLineEnd+
                    @newIndent+@propertyValueComment+@xmlTagLineEndComment+
                    @newIndent+@propertyValueNew+@xmlSpaceTagClose+
                    '</'+@property+'>'+@CR;

            @xmlData += @line;
            @arrayIndex++;
          next // @arrayIndex <= @attrPropertyEntryCount
        
          @idxFeatureValues++;
        next // @idxFeatureValues<(count(@featurePropertyTable)+1) // ### END LOOP 3 ###

        // for method paramdef processing, exit loop and store current index to return later
        if (@abortLoop) then
          @idxLastProcessedEntity = @idxEntity;
          break; // go back to main loop for class features
        endif

        @treeLevel--;
        @xmlData += @treelevel*@TAB+"</"+@classFeatureXmlEntryTagName+">" + @CR;
        @idxEntity++;
      next // @idxEntity<=Count(@featureProperties) // ### END LOOP 2 ###

      @treeLevel--;
 
      // for method paramdef processing, exit loop and store current index to return later
      if (@abortLoop) then     
        @idxLastProcessedFeature = @idxFeature;
        next;
      endif

      if (@classFeatureXmlParentTagName != "") then
          @xmlData += @treelevel*@TAB+"</"+@classFeatureXmlParentTagName+">" + @CR;
         @treeLevel--;
      endif

      // at this point, method paramdef processing is finished and so we switch back to normal processing mode and continue with next property 
      if (@executionMode == @EXECUTION_MODE_METHOD_PARAMS) then
        @idxFeature = @idxLastProcessedFeature;
        @executionMode = @EXECUTION_MODE_DEFAULT;
      else
        @idxFeature++;
      endif  
    next // @idxFeature<count(@featureMappingTable) // ### END LOOP 1 ###
    @xmlData += @treelevel*@TAB+'</class>'+@CR;
    @classDuplicateSuffix = '';
    if (@isDuplicateClass) then 
      @lguid = ToString(@class.$LogicalGUID);
      @lguid = SubStr(@lguid, 2, Length(@lguid)-2);
      @classDuplicateSuffix = @methodIdSeparator + @lguid;
    endif
    @classNameXml = @class.$internalname + @fileNameAppendix + @classDuplicateSuffix + @FILE_EXTENSION_XML;
    @codeExportTableEntry = Array('XML', @classNameXml, @xmlData, "");
    @codeExportTable = InsertValue(@codeExportTable, @codeExportTableEntry);
    if (@xmlCreateCombinedOutputFile) then
      @xmlDataCombined += @xmlData;
    endif
  endif; // @export_XML
  @classIdx++;
next  // @class in (@classSet) 



//===- save PQL code of templates and instances in CodeExportTable -===

if (@export_PQL) then
  @instancePqlCount = 0;
  @templatePqlCount = 0;
  @objSetToExport = union(@instanceSetToExport, @templateSetToExport);
  forEach @obj in (@objSetToExport)
    @objType    = @obj.$objType;
    @objId      = @obj.$id;
    @objName    = @obj.$displayname;
    @objLguid   = @obj.$Logicalguid;
    @objVguid   = @obj.$VersionGUID;
    @objCreator = @obj\$author.$name;
    if (@objCreator==$invalid) then
      @objCreator = "$ISIS$";
    endif
    @className  = @obj\$classGUID.$internalname;
    @creationDate     = Substitute(ToString(date(@obj.$Created)),"/","")+@dateTimeSeparator+Substitute(ToString(time(@obj.$Created)),":","");
    @modificationDate = Substitute(ToString(date(@obj.$Modified)),"/","")+@dateTimeSeparator+Substitute(ToString(time(@obj.$Modified)),":","");
    if (@objType==@OBJECT_TYPE_INSTANCES) then
      @filename = @instanceNamingScheme;
    else
      @filename = @templateNamingScheme;
    endif
    // if whole version chain is exported and filename doesn't contain creation date yet, then add timestamp to filename
    @filenameAppendix = '';
    if (@includeVersionChain) then
      if (Pos('<OBJ_CREATEDATE>', @filename)==0) then
        @filenameAppendix = @filenameComponentSeparator + @creationDate;
      endif
    endif  
    @pqlAttrList = @obj\$inheritance\$attrdef(.$EditMode like @EDITMODE_PQLSTATEMENT).$attrnameintern groupby $attrnameintern;  
    
    forEach @attr in (@pqlAttrList)
      @attrName = @attr.$attrnameintern;
      @pqlStatement = @obj.@attr;
      @pqlStatementLen = length(@pqlStatement);

      // supported variables: <OID>, <LGUID>, <CLASS_NAME>, <OBJ_NAME>, <ATTR_NAME>
      // example naming scheme: (T)<CLASS_NAME>_-_<OBJ_NAME>_<ATTR_NAME>_<LGUID>_<OID>
      @filename = Substitute(@filename, '<OID>',           toString(@objId));
      @filename = Substitute(@filename, '<LGUID>',         toString(@objLguid));
      @filename = Substitute(@filename, '<VGUID>',         toString(@objVguid));
      @filename = Substitute(@filename, '<CLASS_NAME>',    @className);
      @filename = Substitute(@filename, '<OBJ_NAME>',      @objName);
      @filename = Substitute(@filename, '<ATTR_NAME>',     @attrName);     
      @filename = Substitute(@filename, '<DATE_CREATED>',  @creationDate);      
      @filename = Substitute(@filename, '<DATE_MODIFIED>', @modificationDate);
      @filename = Substitute(@filename, '<CREATOR>',       @objCreator);

      @filename += (@filenameAppendix + @FILE_EXTENSION_PQL);
      forEach @char in (@FILENAME_FORBIDDEN_CHARS)
        @filename = Substitute(@filename, @char, @invalidCharReplacement);
      next

      if (@pqlStatementLen>0) then
        @codeExportTableEntry = array('PQL', @filename, @pqlStatement, '');
        @codeExportTable = insertValue(@codeExportTable,@codeExportTableEntry);
        if (@objType==@OBJECT_TYPE_INSTANCES) then
          @instancePqlCount++;
        else
          @templatePqlCount++;
        endif
      endif  
    next
  next
endif



//===- Check code based on regular expressions -===

if (@performCodeCheck) then
  if (@verboseLevel > 0) then
    message(@MSG_INFO, '');
    message(@MSG_INFO,'*** Checking code based on regular expressions ***');
    message(@MSG_INFO, '');
  endif
  ForEach @codeExportTableEntry in (@codeExportTable)

    @fileType = @codeExportTableEntry[1];
    @fileName = @codeExportTableEntry[2];
    @contentToAnalyse = "";
    Select @fileType
      Case 'DFA':
        @fileHandle = FileOpen(@codeExportTableEntry[4], 'CONTENT', 'r');
        @contentToAnalyse = FileReadString(@fileHandle, -1);
        @rc = FileClose(@fileHandle);
        break;
      Case 'PQL':
        @contentToAnalyse = @codeExportTableEntry[3];
        break;
      Case 'XML':
        break;
    EndSelect

    ForEach @searchExpressionsEntry in (@searchExpressions)
      @regEx = @searchExpressionsEntry[1];
      @regExMsg = @searchExpressionsEntry[2];
      @charsBefore = @searchExpressionsEntry[3];
      @charsAfter  = @searchExpressionsEntry[4];
      @lineNumber=0;
      @pos_global = 1;
      @match = RegExpMatch(@contentToAnalyse,@regEx);
      @lines = split(@contentToAnalyse,@CR);
      @inputString = @contentToAnalyse;
      if (count(@match)>0) then
        if (@verboseLevel > 0) then  
          message(@MSG_INFO,' -> File: "'+@fileName+'"');
        endif
      endif

      while (count(@match)>0)
        @pos_global = pos(@match[1],@contentToAnalyse,@pos_global);
        @charsBefore = @searchExpressionsEntry[3];
        @charsAfter  = @searchExpressionsEntry[4];
    
        @prefixCode=left(@contentToAnalyse,@pos_global);
        // determine line number by counting linebreaks (CR)
        @lineNumber=length(@prefixCode)-length(substitute(@prefixCode,@CR,""))+1;
    
        @line = @lines[@lineNumber];
        @pos_line = pos(@match[1],@line);
          
        if (@pos_global<=@charsBefore) then @charsBefore = @pos_global-1; endif
        if (@pos_global+length(@match[1])+@charsAfter>Length(@contentToAnalyse)) then 
          @charsAfter = (Length(@contentToAnalyse) - @pos_global-length(@match[1])+1); 
        endif
             
        @line = SubStr(@contentToAnalyse,@pos_global-@charsBefore,@charsBefore+length(@match[1])+@charsAfter);
        @line = Substitute(@line,@CR,' ');
        if (@verboseLevel > 0) then
          message(@MSG_INFO,"    Found "+@regExMsg+ " in line "+@lineNumber+", position "+ @pos_line);
          if (@verboseLevel > 1) then
            message(@MSG_INFO,'    "...'+@line+'..."');
          endif
        endif
        
        // if code fragment contains semicolon (standard field delimiter for CSV) then mask field using "excel" agorithm
        @needsMasking = Pos(';',@line);
        if (@needsMasking) then
          @line = '"' + Substitute(@line, '"', '""') + '"';
        endif

        //@codeCheckMessageTable structure: 'FILENAME;LINE;POSITION;MESSAGE_TYPE;CODE_CONTEXT';
        @codeCheckMessageTableLine = 
          @fileName + @codeCheckSeparator + @lineNumber + @codeCheckSeparator + @pos_line + @codeCheckSeparator + @regExMsg + @codeCheckSeparator + @line;
        @codeCheckMessageTable = @codeCheckMessageTable + @codeCheckMessageTableLine + @CR;
        @codeCheckMessageCount++;          

        @pos_global = @pos_global + length(@match[1]);
        @inputString = SubStr(@inputString, @pos_global, (Length(@contentToAnalyse)-@pos_global));
        @match = RegExpMatch(@inputString,@regEx);
      next // (count(@match)>0)
    next  // @searchExpressionsEntry in (@searchExpressions)
  next  // @codeExportTableEntry in (@codeExportTable)
endif // (@performCodeCheck)




//===- Export code to filesystem -===

if (@verboseLevel > 0) then
  message(@MSG_INFO, '');
  message(@MSG_INFO,'*** Export files to '+@exportPath+' ***');
  message(@MSG_INFO, '');
endif
@FLAG_CREATE_MISSING_DIR = 1;
@binaryExportFlags = @FLAG_CREATE_MISSING_DIR;

forEach @codeExportTableEntry in (@codeExportTable)

  @fileType = @codeExportTableEntry[1];
  Select @fileType
      Case 'DFA':
        @obj = @codeExportTableEntry[4];
        if (toString(@obj.Content)=='') then
          message(@MSG_WARNING,' The following resource has no binary content: '+ @obj.$name +'.');
        else
          @objCountDFA++;
          @fileName = @codeExportTableEntry[2];
          @exportSuccessful = 1;
          if (@simulateExport==false) then
            if (@isBinExpExtSupported) then
              $local($ie):@rc = @obj.@exportMethodRcResource('CONTENT',@exportPath+@exportFolderDFA+@dirSeparator+@fileName,$Invalid,$Invalid,$Invalid,@binaryExportFlags);
            else
              $local($ie):@rc = @obj.BinaryExport('CONTENT',@exportPath+@exportFolderDFA+@dirSeparator+@fileName);
            endif
            if (@rc != 0) then     
              @exportSuccessful = 0;
              @objCountDFA--;
              message(@MSG_INFO,'     ERROR: '+ @fileName +' could not be exported');
            endif
          endif // (@simulateExport==false)
          if ((@verboseLevel > 0) && (@exportSuccessful)) then 
            message(@MSG_INFO,' -> File '+ @fileName +' was exported successfully');
          endif                  
        endif
        break;
      Case 'PQL':
      Case 'XML':
        if (@fileType=='PQL') then
          @objCountPQL++;
          @exportFolder = @exportFolderPQL;
        elseIf (@fileType=='XML') then
          @objCountXML++;
          @exportFolder = @exportFolderXML;
        endif
        @fileName = @codeExportTableEntry[2];
        @exportSuccessful = 1;
        if (@simulateExport==false) then    
    
          // write PQL statement into binary attribute of export tool
          @fileHandle = FileOpen(@exportTool.$id,'TargetName','w');
          @fileHeader = @codeExportTableEntry[4];
          @pqlStatement = @codeExportTableEntry[3];
      
          @fileHandle.$FileWrite(@fileHeader);
          @fileHandle.$FileWrite(@pqlStatement);
          @fileHandle.$FileClose();
    
          // write binary attribute to file
          if (@isBinExpExtSupported) then
            $local($ie):@rc = @exportTool.@exportMethodData('TargetName',@exportPath+@exportFolder+@dirSeparator+@fileName,$Invalid,$Invalid,$Invalid,@binaryExportFlags);
          else
            $local($ie):@rc = @exportTool.BinaryExport('TargetName',@exportPath+@exportFolder+@dirSeparator+@fileName);
          endif
          if (@rc != 0) then
            @exportSuccessful = 0;
            if (@fileType=='PQL') then
              @objCountPQL--;
            elseIf (@fileType=='XML') then
              @objCountXML--;
            endif
            message(@MSG_INFO,' ERROR: '+ @fileName +' could not be exported');  
          endif  
        endif // (@simulateExport==false)
        if ((@verboseLevel > 0) && (@exportSuccessful)) then 
          message(@MSG_INFO,' -> File '+ @fileName +' was exported successfully');
        endif 
        break;
    EndSelect
next // @line in (@codeExportTable)

// export combined XML data to filesystem
if (@simulateExport==false) then
  if (@export_XML AND @xmlCreateCombinedOutputFile AND @xmlDataCombined != "") then
    @fileName   = @exportPath + @exportFolderXML + @dirSeparator + @xmlCombinedOutputFilename;
    @xmlData    = @XML_HEADER + @xmlDataCombined + @XML_TRAILER;
    @fileHandle = FileOpen(@exportTool.$id,'TargetName','w');
    @fileHandle.$FileWrite(@xmlData);
    @fileHandle.$FileClose();
    // at this point, XML folder should have been created, so no need for "BinaryExportExtended" 
    @rc = @exportTool.BinaryExport(@exportToolBinAttrName,@fileName);
    if (@rc==0) then
      if (@verboseLevel > 1) then
        message(@MSG_INFO, ' -> Combined XML file has been exported to "'+ @fileName+'"');
        @objCountXML++;
      endif
    endif
  endif
endif

// export code-check messages to filesystem
@fileName = @exportPath+@exportFileCodeCheck;
if (@simulateExport==false) then
  if (@codeCheckMessageCount>0) then
    @fileHandle = FileOpen(@exportTool.$id,'TargetName','w');
    @fileHandle.$FileWrite(@codeCheckMessageTable);
    @fileHandle.$FileClose();
    // this file goes into root folder, so no need for "BinaryExportExtended"
    $local($ie):@rc = @exportTool.BinaryExport('TargetName',@fileName);
    if (@rc == 0) then
      if (@verboseLevel > 1) then
        message(@MSG_INFO,' -> Code checker message file has been exported to "'+ @fileName +'"');
      endif
    else
      message(@MSG_INFO,' ERROR: '+ @fileName +' could not be exported');  
    endif
  endif
endif // (@simulateExport==false)


//===- Print summary -===

@simulationMessage = "";
@codeCheckMessage = "";
if (@simulateExport) then
    @simulationMessage = ' [Simulation mode is ON, no files are physically exported.]';
endif
if (@performCodeCheck) then
  @codeCheckMessage = ' '+ Right(toString(@codeCheckMessageCount),5,' ') + ' matches found by code checker. Log saved to '+@exportPath+@exportFileCodeCheck;
endif  
if (@verboseLevel > 0) then
  message(@MSG_INFO, '');
  message(@MSG_INFO, '');
  message(@MSG_INFO, '*** SUMMARY ***' + @simulationMessage);
  message(@MSG_INFO, '--------------------------------------------------------------------------------------------------');
  message(@MSG_INFO,' '+ Right(toString(@objCountPQL),5,' ') + ' PQL files exported to '+@exportPath+@exportFolderPQL);
  if (@export_PQL && (@instanceCount>0 || @templateCount>0)) then
  message(@MSG_INFO,' '+ '      (including ' + @instancePqlCount + ' PQLs from instances and '+@templatePqlCount+' PQLs from templates)');
  endif
  message(@MSG_INFO,' '+ Right(toString(@objCountDFA),5,' ') + ' DocDef/Include files exported to '+@exportPath+@exportFolderDFA);
  message(@MSG_INFO,' '+ Right(toString(@objCountXML),5,' ') + ' XML files exported to '+@exportPath+@exportFolderXML);
  message(@MSG_INFO, @codeCheckMessage);
  message(@MSG_INFO, '==================================================================================================');
  message(@MSG_INFO, ''); 
endif // (@verboseLevel > 0)

@objCountExported = @objCountPQL + @objCountDFA;
return @objCountExported;


// P.S.: never write PQLs longer then 50 lines